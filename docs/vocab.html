---

title: Vocab


keywords: fastai
sidebar: home_sidebar

summary: "Functions related to converting strings into tensors"
description: "Functions related to converting strings into tensors"
nb_path: "nbs/07_vocab.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/07_vocab.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Tokenization">Tokenization<a class="anchor-link" href="#Tokenization"> </a></h2><p>Tokenzation defines how we break text strings (ie SMILES strings) down into subunits that are fed to the model. The standard process goes as follows:</p>
<ol>
<li>A tokenization process breaks a string down into tokens</li>
<li>Tokens are mapped to integers</li>
<li>The token integers are sent to the model</li>
</ol>
<p>This brings up the problem of how best to tokenize smiles. The following methods are implemented out of the box:</p>
<h3 id="Character-Tokenization">Character Tokenization<a class="anchor-link" href="#Character-Tokenization"> </a></h3><p>Character Tokenization is when we break down SMILES by character. This is implemented with the <a href="/mrl/vocab.html#tokenize_by_character"><code>tokenize_by_character</code></a> function.</p>

<pre><code>tokenize_by_character('CC[NH]CC')
&gt; &gt; ['C', 'C', '[', 'N', 'H', ']', 'C', 'C']</code></pre>
<p>This form of tokenization is quick and simple. One drawback of this approach is some characters might be overloaded. For example, <code>Br</code> is tokenized to <code>['B', 'r']</code>, leading to the <code>B</code> token meaning both boron (in the standard context) and Bromine (in the <code>Br</code> context). In practice, this isn't much of an issue. Language models are particularly adept at learning co-location of tokens.</p>
<h3 id="Character-Tokenization-with-Replacement">Character Tokenization with Replacement<a class="anchor-link" href="#Character-Tokenization-with-Replacement"> </a></h3><p>Character tokenization with replacement is the same as character tokenization except we add a dictionary of multi-character tokens to be replaced with single-character tokens. This dictionary has the form <code>{multi_character_token :single_character_token}</code>. Before tokenizing by character, all instances of <code>multi_character_token</code> are replaced with <code>single_character_token</code>. Character Tokenization with Replacement is implemented with the <a href="/mrl/vocab.html#tokenize_with_replacements"><code>tokenize_with_replacements</code></a> function.</p>

<pre><code>replacement_dict = {'Br' : 'R', 'Cl' : 'L'}
tokenize_with_replacements('[Cl]CC[Br]', replacement_dict)
&gt; &gt; ['[', 'L', ']', 'C', 'C', '[', 'R', ']']</code></pre>
<h3 id="Regex-Tokenization">Regex Tokenization<a class="anchor-link" href="#Regex-Tokenization"> </a></h3><p>Regex tokenization uses a regex string to decompose SMILES. This is mainly used to keep bracketed terms (ie <code>[O-]</code>) as single tokens. This method avoids character overloading by keeping all bracketed terms as individual tokens, but has issues with generating a large number of low frequency tokens. Regex tokenization is implemented with the <a href="/mrl/vocab.html#regex_tokenize"><code>regex_tokenize</code></a> function</p>

<pre><code>SMILE_REGEX = """(\[[^\]]+]|Br?|Cl?|N|O|S|P|F|I|b|c|n|o|s|p|H|\(|\)|\.|=|#|-|\+|\\\\|\/|:|~|@|\?|&gt;|\*|\$|\%[0-9]{2}|[0-9])"""regex_tokenize('CCC[Br]', re.compile(SMILE_REGEX))
&gt;&gt;['C', 'C', 'C', '[Br]']</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="pad_vocab" class="doc_header"><code>pad_vocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L103" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>pad_vocab</code>(<strong><code>vocab</code></strong>)</p>
</blockquote>
<p>pads <code>vocab</code> to have a length divisible by 8 - improves fp16 performance</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>These are regex patterns to decompose smiles into tokens</p>
<p><a href="/mrl/vocab.html#SMILE_REGEX"><code>SMILE_REGEX</code></a> is based off <a href="https://github.com/pschwllr/MolecularTransformer/blob/master/README.md">this work</a>. The pattern decomposes SMILES into individual characters, but keeps <code>Cl</code>, <code>Br</code>, and any term in brackets (ie <code>[O-]</code>) intact.</p>
<p><a href="/mrl/vocab.html#MAPPING_REGEX"><code>MAPPING_REGEX</code></a> is a derivative of <a href="/mrl/vocab.html#SMILE_REGEX"><code>SMILE_REGEX</code></a> designed to work with the mapping framework used with the <a href="/mrl/template.blocks.html#Block"><code>Block</code></a> class. <a href="/mrl/vocab.html#MAPPING_REGEX"><code>MAPPING_REGEX</code></a> keeps <code>Cl</code>, <code>Br</code>, and any string of the form <code>[{isotope}*:{map_num}]</code> intact</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_by_character" class="doc_header"><code>tokenize_by_character</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L126" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_by_character</code>(<strong><code>input</code></strong>)</p>
</blockquote>
<p>Splits <code>input</code> into inividual characters</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_with_replacements" class="doc_header"><code>tokenize_with_replacements</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L139" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_with_replacements</code>(<strong><code>input</code></strong>, <strong><code>replacement_dict</code></strong>)</p>
</blockquote>
<p>Replaces substrings in <code>input</code> using <code>replacement_dict</code>, then tokenizes by character</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="regex_tokenize" class="doc_header"><code>regex_tokenize</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L145" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>regex_tokenize</code>(<strong><code>input</code></strong>, <strong><code>regex</code></strong>)</p>
</blockquote>
<p>Uses <code>regex</code> to tokenize <code>input</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">tokenize_by_character</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">tokenize_with_replacements</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">,</span> <span class="n">HALOGEN_REPLACE</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">regex_tokenize</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">SMILE_REGEX</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">regex_tokenize</span><span class="p">(</span><span class="s1">&#39;[1*:1]CCC[Br]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">MAPPING_REGEX</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;[1*:1]&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;Br&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Vocabulary">Vocabulary<a class="anchor-link" href="#Vocabulary"> </a></h2><p>The <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a> class handles tokenization. <a href="/mrl/vocab.html#Vocab.tokenize"><code>Vocab.tokenize</code></a> breaks strings down into tokens. <a href="/mrl/vocab.html#Vocab.numericalize"><code>Vocab.numericalize</code></a> maps tokens to integers. <a href="/mrl/vocab.html#Vocab.reconstruct"><code>Vocab.reconstruct</code></a> converts integers back into strings.</p>
<p><a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a> holds <code>itos</code>, a list of tokens, and <code>stoi</code>, a dictionary mapping tokens to integers. <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a> automatically adds four special tokens <code>['bos', 'eos', 'pad', 'unk']</code> indicating beginning of sentence, end of sentence, padding and unknown.</p>
<h3 id="Custom-Vocbulary">Custom Vocbulary<a class="anchor-link" href="#Custom-Vocbulary"> </a></h3><p>To implement custom tokenization, subclass <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a> and update the <code>tokenize</code>, <code>numericalize</code> and <code>reconstruct</code> methods. Use the <a href="/mrl/vocab.html#test_reconstruction"><code>test_reconstruction</code></a> function to verify your custom vocab can successfully reconstruct sequences.</p>
<p>Vocabs also have <code>prefunc</code> and <code>postfunc</code> hooks for added flexibility. <code>prefunc</code> is called on the inputs to <code>tokenize</code> before tokenization. <code>postfunc</code> is called during <code>reconstruct</code> after tokens are joined.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Vocab" class="doc_header"><code>class</code> <code>Vocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L152" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Vocab</code>(<strong><code>itos</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Vocab - base vocabulary class</p>
<p>Inputs:</p>
<ul>
<li><p><code>itos list</code>: list of tokens in vocabulary</p>
</li>
<li><p><code>prefunc Optional[Callable]</code>: function applied to <code>input</code> before tokenization</p>
</li>
<li><p><code>postfunc Optional[Callable]</code>: function applied to <code>input</code> after reconstruction</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CharacterVocab" class="doc_header"><code>class</code> <code>CharacterVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L244" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CharacterVocab</code>(<strong><code>itos</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>CharacterVocab - tokenize by character</p>
<p>Inputs:</p>
<ul>
<li><p><code>itos list</code>: list of tokens in vocabulary</p>
</li>
<li><p><code>prefunc Optional[Callable]</code>: function applied to <code>input</code> before tokenization</p>
</li>
<li><p><code>postfunc Optional[Callable]</code>: function applied to <code>input</code> after reconstruction</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="FuncVocab" class="doc_header"><code>class</code> <code>FuncVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L260" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>FuncVocab</code>(<strong><code>itos</code></strong>, <strong><code>tok_func</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>FuncVocab - tokenize by <code>tok_func</code></p>
<p>Inputs:</p>
<ul>
<li><p><code>itos list</code>: list of tokens in vocabulary</p>
</li>
<li><p><code>tok_func Callable</code>: tokenization function</p>
</li>
<li><p><code>prefunc Optional[Callable]</code>: function applied to <code>input</code> before tokenization</p>
</li>
<li><p><code>postfunc Optional[Callable]</code>: function applied to <code>input</code> after reconstruction</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SelfiesVocab" class="doc_header"><code>class</code> <code>SelfiesVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L284" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SelfiesVocab</code>(<strong><code>itos</code></strong>) :: <a href="/mrl/vocab.html#FuncVocab"><code>FuncVocab</code></a></p>
</blockquote>
<p>SelfiesVocab - converts smiles to selfies</p>
<p>Inputs:</p>
<ul>
<li><code>itos list</code>: list of tokens in vocabulary</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CharacterReplaceVocab" class="doc_header"><code>class</code> <code>CharacterReplaceVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L296" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CharacterReplaceVocab</code>(<strong><code>itos</code></strong>, <strong><code>replace_dict</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>CharacterReplaceVocab - tokenize by character with replacement</p>
<p>Inputs:</p>
<ul>
<li><p><code>itos list</code>: list of tokens in vocabulary</p>
</li>
<li><p><code>replace_dict dict</code>: replacement dictionary of the form
{multi_character_token : single_character_token}.
ie replace_dict={'Br':'R', 'Cl':'L'}</p>
</li>
<li><p><code>prefunc Optional[Callable]</code>: function applied to <code>input</code> before tokenization</p>
</li>
<li><p><code>postfunc Optional[Callable]</code>: function applied to <code>input</code> after reconstruction</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RegexVocab" class="doc_header"><code>class</code> <code>RegexVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L344" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RegexVocab</code>(<strong><code>itos</code></strong>, <strong><code>pattern</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>RegexVocab - tokenize using <code>pattern</code></p>
<p>Inputs:</p>
<ul>
<li><p><code>itos list</code>: list of tokens in vocabulary</p>
</li>
<li><p><code>pattern str</code>: regex string</p>
</li>
<li><p><code>prefunc Optional[Callable]</code>: function applied to <code>input</code> before tokenization</p>
</li>
<li><p><code>postfunc Optional[Callable]</code>: function applied to <code>input</code> after reconstruction</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="test_reconstruction" class="doc_header"><code>test_reconstruction</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L371" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>test_reconstruction</code>(<strong><code>vocab</code></strong>, <strong><code>inputs</code></strong>)</p>
</blockquote>
<p>Returns all items in <code>inputs</code> that can't be correctly reconstructed using <code>vocab</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;files/smiles.csv&#39;</span><span class="p">)</span>
<span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">FuncVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">tokenize_by_character</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterReplaceVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">HALOGEN_REPLACE</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;CC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bos&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">RegexVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">SMILE_REGEX</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;CC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bos&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">]</span>
<span class="n">vocab</span><span class="o">.</span><span class="n">update_vocab_from_data</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Vocab-Example---Removing-Stereochemistry">Vocab Example - Removing Stereochemistry<a class="anchor-link" href="#Vocab-Example---Removing-Stereochemistry"> </a></h2><p>Stereochemistry is represented in SMILES strings using the <code>@</code> character. For example, <code>C[C@H](N)C(=O)O</code> and <code>C[C@@H](N)C(=O)O</code> represent two different stereoisomers for the same compound.</p>
<p>Stereochemistry in SMILES strings can lead to interesting outcomes for ML models. Predictive models can overfit to specific stereocenters present in training data, and generative models can fall into a form of mode collapse of predicting different stereoisomers of the same compound, or generating excessive stereocenters.</p>
<p>For these reasons, we may wish to deal with generic SMILES strings without stereochemistry information.</p>
<p>One way to do this is to bulk preprocess datasets to remove stereochemistry information, but this requires storing a copy of the stereochemistry-free data, which can be prohibitive for large datasets.</p>
<p>Another way would be to apply stereochemistry removal as a <code>prefunc</code> in our <a href="/mrl/vocab.html#Vocab"><code>Vocab</code></a>, which will remove stereochemistry on the fly before tokenization.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">mrl.chem</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">V1</span> <span class="o">=</span> <span class="n">CharacterVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">)</span>
<span class="n">V2</span> <span class="o">=</span> <span class="n">CharacterVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">prefunc</span><span class="o">=</span><span class="n">remove_stereo</span><span class="p">)</span>

<span class="k">assert</span> <span class="s1">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">V1</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;C[C@H](N)C(=O)O&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="s1">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">V2</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;C[C@H](N)C(=O)O&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">V1</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">numericalize</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;C[C@H](N)C(=O)O&#39;</span><span class="p">)))</span> <span class="o">==</span> <span class="s1">&#39;C[C@H](N)C(=O)O&#39;</span>
<span class="k">assert</span> <span class="n">V2</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">V2</span><span class="o">.</span><span class="n">numericalize</span><span class="p">(</span><span class="n">V2</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;C[C@H](N)C(=O)O&#39;</span><span class="p">)))</span> <span class="o">==</span> <span class="s1">&#39;CC(N)C(=O)O&#39;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Vocab-Example---SELFIES-Vocab">Vocab Example - SELFIES Vocab<a class="anchor-link" href="#Vocab-Example---SELFIES-Vocab"> </a></h2><p><a href="https://github.com/aspuru-guzik-group/selfies">SELFIES</a> is molecule text representation alternative to SMILES strings. One advantage of using SELFIES representations is token swaps in SELFIES strings always result in valid compounds.</p>
<p>MRL is standardized around using SMILES representations for working with compounds, so we can't use SELFIES representations for RL training (unless you want to write a parallel SELFIES-compatible version of all the comp chem functions).</p>
<p>Luckily, we can make use of <code>prefunc</code> and <code>postfunc</code> utilities to use SELFIES representations in our generative models. We can use <a href="/mrl/chem.html#smile_to_selfie"><code>smile_to_selfie</code></a> as a prefunc and <a href="/mrl/chem.html#selfie_to_smile"><code>selfie_to_smile</code></a> as a postfunc.</p>
<p>This means we can keep all our data in SMILES forms for compatibility. When we process SMILES for the model, we first use the <code>prefunc</code> to convert SMILES to SELFIES. Then we tokenize, numericalize and train models in selfies space. Then when we reconstruct a sequence, we use the <code>postfunc</code> to convert it back into SMILES strings.</p>
<p>From the outside perspective, the model takes in and produces SMILES strings. But internally, everything is in SELFIES space.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">mrl.chem</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">vocab</span> <span class="o">=</span> <span class="n">FuncVocab</span><span class="p">(</span><span class="n">SELFIES_VOCAB</span><span class="p">,</span> <span class="n">split_selfie</span><span class="p">,</span> 
                  <span class="n">prefunc</span><span class="o">=</span><span class="n">smile_to_selfie</span><span class="p">,</span> <span class="n">postfunc</span><span class="o">=</span><span class="n">selfie_to_smile</span><span class="p">)</span>

<span class="n">smile</span> <span class="o">=</span> <span class="s1">&#39;COc1ccc2[nH]cc(CCNC(C)=O)c2c1&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SMILE: </span><span class="si">{</span><span class="n">smile</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">selfie</span> <span class="o">=</span> <span class="n">vocab</span><span class="o">.</span><span class="n">prefunc</span><span class="p">(</span><span class="n">smile</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;SELFIE: </span><span class="si">{</span><span class="n">selfie</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">postfunc</span><span class="p">(</span><span class="n">vocab</span><span class="o">.</span><span class="n">prefunc</span><span class="p">(</span><span class="n">smile</span><span class="p">))</span> <span class="o">==</span> <span class="n">smile</span> <span class="c1"># note - only works of smile is canonicalized</span>

<span class="n">full_recon</span> <span class="o">=</span> <span class="n">vocab</span><span class="o">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">vocab</span><span class="o">.</span><span class="n">numericalize</span><span class="p">(</span><span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">smile</span><span class="p">)))</span>
<span class="n">partial_recon</span> <span class="o">=</span> <span class="n">vocab</span><span class="o">.</span><span class="n">join_tokens</span><span class="p">(</span><span class="n">vocab</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">(</span><span class="n">vocab</span><span class="o">.</span><span class="n">numericalize</span><span class="p">(</span><span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">smile</span><span class="p">))))</span>

<span class="k">assert</span> <span class="n">full_recon</span> <span class="o">==</span> <span class="n">smile</span>
<span class="k">assert</span> <span class="n">partial_recon</span> <span class="o">==</span> <span class="n">selfie</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>SMILE: COc1ccc2[nH]cc(CCNC(C)=O)c2c1
SELFIE: [C][O][C][C][=C][C][NHexpl][C][=C][Branch1_1][Branch2_2][C][C][N][C][Branch1_1][C][C][=O][C][Expl=Ring1][O][C][Expl=Ring1][#C]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

