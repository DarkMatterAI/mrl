---

title: Vocab

keywords: fastai
sidebar: home_sidebar

summary: "Functions related to converting strings into tensors"
description: "Functions related to converting strings into tensors"
nb_path: "nbs/07_vocab.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/07_vocab.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Tokenization">Tokenization<a class="anchor-link" href="#Tokenization"> </a></h2><p>Tokenzation defines how we break text strings (ie SMILES strings) down into subunits that are fed to the model. The standard process goes as follows:</p>
<ol>
<li>A tokenization process breaks a string down into tokens</li>
<li>Tokens are mapped to integers</li>
<li>The token integers are sent to the model</li>
</ol>
<p>This brings up the problem of how best to tokenize smiles. The following methods are implemented out of the box:</p>
<h3 id="Character-Tokenization">Character Tokenization<a class="anchor-link" href="#Character-Tokenization"> </a></h3><p>Character Tokenization is when we break down SMILES by character. This is implemented with the <a href="/mrl/vocab#tokenize_by_character"><code>tokenize_by_character</code></a> function.</p>

<pre><code>tokenize_by_character('CC[NH]CC')
&gt; &gt; ['C', 'C', '[', 'N', 'H', ']', 'C', 'C']</code></pre>
<p>This form of tokenization is quick and simple. One drawback of this approach is some characters might be overloaded. For example, <code>Br</code> is tokenized to <code>['B', 'r']</code>, leading to the <code>B</code> token meaning both boron (in the standard context) and Bromine (in the <code>Br</code> context). In practice, this isn't much of an issue. Language models are particularly adept at learning co-location of tokens.</p>
<h3 id="Character-Tokenization-with-Replacement">Character Tokenization with Replacement<a class="anchor-link" href="#Character-Tokenization-with-Replacement"> </a></h3><p>Character tokenization with replacement is the same as character tokenization except we add a dictionary of multi-character tokens to be replaced with singel-character tokens. This dictinary has the form <code>{multi_character_token :single_character_token}</code>. Before tokenizing by character, all instances of <code>multi_character_token</code> are replaced with <code>single_character_token</code>. Character Tokenization with Replacement is implemented with the <a href="/mrl/vocab#tokenize_with_replacements"><code>tokenize_with_replacements</code></a> function.</p>

<pre><code>replacement_dict = {'Br' : 'R', 'Cl' : 'L'}
tokenize_with_replacements('[Cl]CC[Br]', replacement_dict)
&gt; &gt; ['[', 'L', ']', 'C', 'C', '[', 'R', ']']</code></pre>
<h3 id="Regex-Tokenization">Regex Tokenization<a class="anchor-link" href="#Regex-Tokenization"> </a></h3><p>Regex tokenization uses a regex string to decompose SMILES. This is mainly used to keep bracketed terms (ie <code>[O-]</code>) as single tokens. This method avoids character overloading by keeping all bracketed terms as individual tokens, but has issues with generating a large number of low frequency tokens. Regex tokenization is implemented with the <a href="/mrl/vocab#regex_tokenize"><code>regex_tokenize</code></a> function</p>

<pre><code>SMILE_REGEX = """(\[[^\]]+]|Br?|Cl?|N|O|S|P|F|I|b|c|n|o|s|p|H|\(|\)|\.|=|#|-|\+|\\\\|\/|:|~|@|\?|&gt;|\*|\$|\%[0-9]{2}|[0-9])"""regex_tokenize('CCC[Br]', re.compile(SMILE_REGEX))
&gt;&gt;['C', 'C', 'C', '[Br]']</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">pad_vocab</span><span class="p">(</span><span class="n">vocab</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">vocab</span><span class="p">)</span><span class="o">%</span><span class="k">8</span>==0:
        <span class="n">final_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vocab</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span>
        <span class="n">to_add</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vocab</span><span class="p">)</span> <span class="o">-</span> <span class="n">final_length</span>
        <span class="n">vocab</span> <span class="o">=</span> <span class="n">vocab</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;extra&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">to_add</span>
        
    <span class="k">return</span> <span class="n">vocab</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>These are regex patterns to decompose smiles into tokens</p>
<p><a href="/mrl/vocab#SMILE_REGEX"><code>SMILE_REGEX</code></a> is based off <a href="https://github.com/pschwllr/MolecularTransformer/blob/master/README.md">this work</a>. The pattern decomposes SMILES into individual characters, but keeps <code>Cl</code>, <code>Br</code>, and any term in brackets (ie <code>[O-]</code>) intact.</p>
<p><a href="/mrl/vocab#MAPPING_REGEX"><code>MAPPING_REGEX</code></a> is a derivative of <a href="/mrl/vocab#SMILE_REGEX"><code>SMILE_REGEX</code></a> designed to work with the mapping framework used with the <a href="/mrl/template.blocks#Block"><code>Block</code></a> class. <a href="/mrl/vocab#MAPPING_REGEX"><code>MAPPING_REGEX</code></a> keeps <code>Cl</code>, <code>Br</code>, and any string of the form <code>[{isotope}*:{map_num}]</code> intact</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_by_character" class="doc_header"><code>tokenize_by_character</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L113" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_by_character</code>(<strong><code>input</code></strong>)</p>
</blockquote>
<p>Splits <code>input</code> into inividual characters</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_with_replacements" class="doc_header"><code>tokenize_with_replacements</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L126" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_with_replacements</code>(<strong><code>input</code></strong>, <strong><code>replacement_dict</code></strong>)</p>
</blockquote>
<p>Replaces substrings in <code>input</code> using <code>replacement_dict</code>, then tokenizes by character</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="regex_tokenize" class="doc_header"><code>regex_tokenize</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L132" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>regex_tokenize</code>(<strong><code>input</code></strong>, <strong><code>regex</code></strong>)</p>
</blockquote>
<p>Uses <code>regex</code> to tokenize <code>input</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">tokenize_by_character</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">tokenize_with_replacements</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">,</span> <span class="n">HALOGEN_REPLACE</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">regex_tokenize</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">SMILE_REGEX</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">regex_tokenize</span><span class="p">(</span><span class="s1">&#39;[1*:1]CCC[Br]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">MAPPING_REGEX</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;[1*:1]&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;Br&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Vocabulary">Vocabulary<a class="anchor-link" href="#Vocabulary"> </a></h2><p>The <a href="/mrl/vocab#Vocab"><code>Vocab</code></a> class handles tokenization. <a href="/mrl/vocab#Vocab.tokenize"><code>Vocab.tokenize</code></a> breaks strings down into tokens. <a href="/mrl/vocab#Vocab.numericalize"><code>Vocab.numericalize</code></a> maps tokens to integers. <a href="/mrl/vocab#Vocab.reconstruct"><code>Vocab.reconstruct</code></a> converts integers back into strings.</p>
<p><a href="/mrl/vocab#Vocab"><code>Vocab</code></a> holds <code>itos</code>, a list of tokens, and <code>stoi</code>, a dictionary mapping tokens to integers. <a href="/mrl/vocab#Vocab"><code>Vocab</code></a> automatically adds four special tokens <code>['bos', 'eos', 'pad', 'unk']</code> indicating beginning of sentence, end of sentence, padding and unknown.</p>
<h3 id="Custom-Vocbulary">Custom Vocbulary<a class="anchor-link" href="#Custom-Vocbulary"> </a></h3><p>To implement custom tokenization, subclass <a href="/mrl/vocab#Vocab"><code>Vocab</code></a> and update the <code>tokenize</code>, <code>numericalize</code> and <code>reconstruct</code> methods. Use the <a href="/mrl/vocab#test_reconstruction"><code>test_reconstruction</code></a> function to verify your custom vocab can successfully reconstruct sequences.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Vocab" class="doc_header"><code>class</code> <code>Vocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L139" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Vocab</code>(<strong><code>itos</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>)</p>
</blockquote>
<p>Vocab - base vocabulary class</p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens in vocabulary

`prefunc` - None, Callable, function applied to `input` before tokenization

`postfunc` - None, Callable, function applied to `input` after reconstruction</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CharacterVocab" class="doc_header"><code>class</code> <code>CharacterVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L231" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CharacterVocab</code>(<strong><code>itos</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>CharacterVocab - tokenize by character</p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens in vocabulary

`prefunc` - None, Callable, function applied to `input` before tokenization

`postfunc` - None, Callable, function applied to `input` after reconstruction</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="FuncVocab" class="doc_header"><code>class</code> <code>FuncVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L247" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>FuncVocab</code>(<strong><code>itos</code></strong>, <strong><code>tok_func</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>FuncVocab - tokenize by <code>tok_func</code></p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens in vocabulary

`tok_func` - Callable, tokenization function

`prefunc` - None, Callable, function applied to `input` before tokenization

`postfunc` - None, Callable, function applied to `input` after reconstruction</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="SelfiesVocab" class="doc_header"><code>class</code> <code>SelfiesVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L271" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>SelfiesVocab</code>(<strong><code>itos</code></strong>) :: <a href="/mrl/vocab#FuncVocab"><code>FuncVocab</code></a></p>
</blockquote>
<p>SelfiesVocab - converts smiles to selfies</p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens in vocabulary</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CharacterReplaceVocab" class="doc_header"><code>class</code> <code>CharacterReplaceVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L283" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CharacterReplaceVocab</code>(<strong><code>itos</code></strong>, <strong><code>replace_dict</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>CharacterReplaceVocab - tokenize by character with replacement</p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens

`replace_dict` - dict, replacement dictionary of the form {multi_character_token : single_character_token}.
ie replace_dict={'Br':'R', 'Cl':'L'}

`prefunc` - None, Callable, function applied to `input` before tokenization

`postfunc` - None, Callable, function applied to `input` after reconstruction</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RegexVocab" class="doc_header"><code>class</code> <code>RegexVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L330" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RegexVocab</code>(<strong><code>itos</code></strong>, <strong><code>pattern</code></strong>, <strong><code>prefunc</code></strong>=<em><code>None</code></em>, <strong><code>postfunc</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/vocab#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>RegexVocab - tokenize using <code>pattern</code></p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens

`pattern` - str, regex string

`prefunc` - None, Callable, function applied to `input` before tokenization

`postfunc` - None, Callable, function applied to `input` after reconstruction</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="test_reconstruction" class="doc_header"><code>test_reconstruction</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/vocab.py#L357" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>test_reconstruction</code>(<strong><code>vocab</code></strong>, <strong><code>inputs</code></strong>)</p>
</blockquote>
<p>Returns all items in <code>inputs</code> that can't be correctly reconstructed using <a href="/mrl/vocab"><code>vocab</code></a></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;files/smiles.csv&#39;</span><span class="p">)</span>
<span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">FuncVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">tokenize_by_character</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterReplaceVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">HALOGEN_REPLACE</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;CC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bos&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">RegexVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">SMILE_REGEX</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;CC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bos&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">]</span>
<span class="n">vocab</span><span class="o">.</span><span class="n">update_vocab_from_data</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

