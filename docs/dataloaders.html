---

title: Dataloaders


keywords: fastai
sidebar: home_sidebar

summary: "Pytorch datasets, dataloaders, collate functions and vocabularies"
description: "Pytorch datasets, dataloaders, collate functions and vocabularies"
nb_path: "nbs/07_dataloaders.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/07_dataloaders.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Tokenization">Tokenization<a class="anchor-link" href="#Tokenization"> </a></h2><p>Tokenzation defines how we break text strings (ie SMILES strings) down into subunits that are fed to the model. The standard process goes as follows:</p>
<ol>
<li>A tokenization process breaks a string down into tokens</li>
<li>Tokens are mapped to integers</li>
<li>The token integers are sent to the model</li>
</ol>
<p>This brings up the problem of how best to tokenize smiles. The following methods are implemented out of the box:</p>
<h3 id="Character-Tokenization">Character Tokenization<a class="anchor-link" href="#Character-Tokenization"> </a></h3><p>Character Tokenization is when we break down SMILES by character. This is implemented with the <a href="/mrl/dataloaders.html#tokenize_by_character"><code>tokenize_by_character</code></a> function.</p>

<pre><code>tokenize_by_character('CC[NH]CC')
&gt; &gt; ['C', 'C', '[', 'N', 'H', ']', 'C', 'C']</code></pre>
<p>This form of tokenization is quick and simple. One drawback of this approach is some characters might be overloaded. For example, <code>Br</code> is tokenized to <code>['B', 'r']</code>, leading to the <code>B</code> token meaning both boron (in the standard context) and Bromine (in the <code>Br</code> context). In practice, this isn't much of an issue. Language models are particularly adept at learning co-location of tokens.</p>
<h3 id="Character-Tokenization-with-Replacement">Character Tokenization with Replacement<a class="anchor-link" href="#Character-Tokenization-with-Replacement"> </a></h3><p>Character tokenization with replacement is the same as character tokenization except we add a dictionary of multi-character tokens to be replaced with singel-character tokens. This dictinary has the form <code>{multi_character_token :single_character_token}</code>. Before tokenizing by character, all instances of <code>multi_character_token</code> are replaced with <code>single_character_token</code>. Character Tokenization with Replacement is implemented with the <a href="/mrl/dataloaders.html#tokenize_with_replacements"><code>tokenize_with_replacements</code></a> function.</p>

<pre><code>replacement_dict = {'Br' : 'R', 'Cl' : 'L'}
tokenize_with_replacements('[Cl]CC[Br]', replacement_dict)
&gt; &gt; ['[', 'L', ']', 'C', 'C', '[', 'R', ']']</code></pre>
<h3 id="Regex-Tokenization">Regex Tokenization<a class="anchor-link" href="#Regex-Tokenization"> </a></h3><p>Regex tokenization uses a regex string to decompose SMILES. This is mainly used to keep bracketed terms (ie <code>[O-]</code>) as single tokens. This method avoids character overloading by keeping all bracketed terms as individual tokens, but has issues with generating a large number of low frequency tokens. Regex tokenization is implemented with the <a href="/mrl/dataloaders.html#regex_tokenize"><code>regex_tokenize</code></a> function</p>

<pre><code>SMILE_REGEX = """(\[[^\]]+]|Br?|Cl?|N|O|S|P|F|I|b|c|n|o|s|p|H|\(|\)|\.|=|#|-|\+|\\\\|\/|:|~|@|\?|&gt;|\*|\$|\%[0-9]{2}|[0-9])"""regex_tokenize('CCC[Br]', re.compile(SMILE_REGEX))
&gt;&gt;['C', 'C', 'C', '[Br]']</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>These are regex patterns to decompose smiles into tokens</p>
<p><a href="/mrl/dataloaders.html#SMILE_REGEX"><code>SMILE_REGEX</code></a> is based off <a href="https://github.com/pschwllr/MolecularTransformer/blob/master/README.md">this work</a>. The pattern decomposes SMILES into individual characters, but keeps <code>Cl</code>, <code>Br</code>, and any term in brackets (ie <code>[O-]</code>) intact.</p>
<p><a href="/mrl/dataloaders.html#MAPPING_REGEX"><code>MAPPING_REGEX</code></a> is a derivative of <a href="/mrl/dataloaders.html#SMILE_REGEX"><code>SMILE_REGEX</code></a> designed to work with the mapping framework used with the <a href="/mrl/template.blocks.html#Block"><code>Block</code></a> class. <a href="/mrl/dataloaders.html#MAPPING_REGEX"><code>MAPPING_REGEX</code></a> keeps <code>Cl</code>, <code>Br</code>, and any string of the form <code>[{isotope}*:{map_num}]</code> intact</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_by_character" class="doc_header"><code>tokenize_by_character</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L55" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_by_character</code>(<strong><code>input</code></strong>)</p>
</blockquote>
<p>Splits <code>input</code> into inividual characters</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="tokenize_with_replacements" class="doc_header"><code>tokenize_with_replacements</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L68" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>tokenize_with_replacements</code>(<strong><code>input</code></strong>, <strong><code>replacement_dict</code></strong>)</p>
</blockquote>
<p>Replaces substrings in <code>input</code> using <code>replacement_dict</code>, then tokenizes by character</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="regex_tokenize" class="doc_header"><code>regex_tokenize</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L74" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>regex_tokenize</code>(<strong><code>input</code></strong>, <strong><code>regex</code></strong>)</p>
</blockquote>
<p>Uses <code>regex</code> to tokenize <code>input</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">tokenize_by_character</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">tokenize_with_replacements</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">,</span> <span class="n">HALOGEN_REPLACE</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">regex_tokenize</span><span class="p">(</span><span class="s1">&#39;CCC[Br]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">SMILE_REGEX</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">regex_tokenize</span><span class="p">(</span><span class="s1">&#39;[1*:1]CCC[Br]&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">MAPPING_REGEX</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;[1*:1]&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;Br&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Vocabulary">Vocabulary<a class="anchor-link" href="#Vocabulary"> </a></h2><p>The <a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a> class handles tokenization. <a href="/mrl/dataloaders.html#Vocab.tokenize"><code>Vocab.tokenize</code></a> breaks strings down into tokens. <a href="/mrl/dataloaders.html#Vocab.numericalize"><code>Vocab.numericalize</code></a> maps tokens to integers. <a href="/mrl/dataloaders.html#Vocab.reconstruct"><code>Vocab.reconstruct</code></a> converts integers back into strings.</p>
<p><a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a> holds <code>itos</code>, a list of tokens, and <code>stoi</code>, a dictionary mapping tokens to integers. <a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a> automatically adds four special tokens <code>['bos', 'eos', 'pad', 'unk']</code> indicating beginning of sentence, end of sentence, padding and unknown.</p>
<h3 id="Custom-Vocbulary">Custom Vocbulary<a class="anchor-link" href="#Custom-Vocbulary"> </a></h3><p>To implement custom tokenization, subclass <a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a> and update the <code>tokenize</code>, <code>numericalize</code> and <code>reconstruct</code> methods. Use the <a href="/mrl/dataloaders.html#test_reconstruction"><code>test_reconstruction</code></a> function to verify your custom vocab can successfully reconstruct sequences.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Vocab" class="doc_header"><code>class</code> <code>Vocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L81" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Vocab</code>(<strong><code>itos</code></strong>)</p>
</blockquote>
<p>Vocab - base vocabulary class</p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens in vocabulary</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CharacterVocab" class="doc_header"><code>class</code> <code>CharacterVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L144" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CharacterVocab</code>(<strong><code>itos</code></strong>) :: <a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>CharacterVocab - tokenize by character</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CharacterReplaceVocab" class="doc_header"><code>class</code> <code>CharacterReplaceVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L154" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CharacterReplaceVocab</code>(<strong><code>itos</code></strong>, <strong><code>replace_dict</code></strong>) :: <a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>CharacterReplaceVocab - tokenize by character with replacement</p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens
`replace_dict` - dict, replacement dictionary of the form {multi_character_token : single_character_token}.
ie replace_dict={'Br':'R', 'Cl':'L'}</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RegexVocab" class="doc_header"><code>class</code> <code>RegexVocab</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L196" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RegexVocab</code>(<strong><code>itos</code></strong>, <strong><code>pattern</code></strong>) :: <a href="/mrl/dataloaders.html#Vocab"><code>Vocab</code></a></p>
</blockquote>
<p>RegexVocab - tokenize using <code>pattern</code></p>
<p>Inputs:</p>

<pre><code>`itos` - list, list of tokens
`pattern` - str, regex string</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="test_reconstruction" class="doc_header"><code>test_reconstruction</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L218" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>test_reconstruction</code>(<strong><code>vocab</code></strong>, <strong><code>inputs</code></strong>)</p>
</blockquote>
<p>Returns all items in <code>inputs</code> that can't be correctly reconstructed using <code>vocab</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;files/smiles.csv&#39;</span><span class="p">)</span>
<span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterReplaceVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">HALOGEN_REPLACE</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;CC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bos&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[&#39;</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">,</span> <span class="s1">&#39;]&#39;</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">]</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="n">RegexVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">,</span> <span class="n">SMILE_REGEX</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">vocab</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="s1">&#39;CC[Br]&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bos&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;[Br]&#39;</span><span class="p">,</span> <span class="s1">&#39;eos&#39;</span><span class="p">]</span>
<span class="n">vocab</span><span class="o">.</span><span class="n">update_vocab_from_data</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">test_reconstruction</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">smiles</span><span class="p">)</span><span class="o">==</span><span class="p">[]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Collate-Functions">Collate Functions<a class="anchor-link" href="#Collate-Functions"> </a></h2><p>Collate functions are used to batch <code>Dataset</code> outputs into batches</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="batch_sequences" class="doc_header"><code>batch_sequences</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L230" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>batch_sequences</code>(<strong><code>sequences</code></strong>, <strong><code>pad_idx</code></strong>)</p>
</blockquote>
<p>Packs <code>sequences</code> into a dense tensor, using <code>pad_idx</code> for padding</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="lm_collate" class="doc_header"><code>lm_collate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L243" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>lm_collate</code>(<strong><code>batch</code></strong>, <strong><code>pad_idx</code></strong>, <strong><code>batch_first</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Collate function for language models. Returns packed
batch for next-token prediction</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="sequence_prediction_collate" class="doc_header"><code>sequence_prediction_collate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L258" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>sequence_prediction_collate</code>(<strong><code>batch</code></strong>, <strong><code>pad_idx</code></strong>, <strong><code>batch_first</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Collate function for predicting some y value from a sequence</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="vector_collate" class="doc_header"><code>vector_collate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L271" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>vector_collate</code>(<strong><code>batch</code></strong>)</p>
</blockquote>
<p>Collate function for vectors</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="vector_reconstruction_collate" class="doc_header"><code>vector_reconstruction_collate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L278" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>vector_reconstruction_collate</code>(<strong><code>batch</code></strong>, <strong><code>pad_idx</code></strong>, <strong><code>batch_first</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Collate function for predicting a sequence from an input vector where
<code>batch_tensor</code> is needed for input (ie predict SMILES from properties)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="vector_prediction_collate" class="doc_header"><code>vector_prediction_collate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L294" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>vector_prediction_collate</code>(<strong><code>batch</code></strong>)</p>
</blockquote>
<p>Collate function for predicting some y value from a vector</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Datasets">Datasets<a class="anchor-link" href="#Datasets"> </a></h2><p>Datasets subclass the Pytorch <code>Dataset</code> class. MRL datasets add a collate function and the <a href="/mrl/dataloaders.html#BaseDataset.dataloader"><code>BaseDataset.dataloader</code></a> function to easily generate Pytorch dataloaders from the same class</p>
<p>Datasets should all contain a <code>new</code> method. The purpose of <code>new</code> is to create a new dataset from new data using the same input arguments as the current dataset. This is used during generative training to process and batch generated samples to ensure they are processed and batched the same as training data</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BaseDataset" class="doc_header"><code>class</code> <code>BaseDataset</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L306" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BaseDataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <code>Dataset</code></p>
</blockquote>
<p>BaseDataset - base dataset</p>
<p>Inputs:</p>

<pre><code>`collate_function` - batch collate function for the particular dataset class</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Text-Datasets">Text Datasets<a class="anchor-link" href="#Text-Datasets"> </a></h2><p>Text datasets deal with tokenizing and numericalizing text data, like SMILES strings.</p>
<p><a href="/mrl/dataloaders.html#TextDataset"><code>TextDataset</code></a> returns numericalized SMILES for language modeling.</p>
<p><a href="/mrl/dataloaders.html#TextPredictionDataset"><code>TextPredictionDataset</code></a> returns numericaized SMILES along with some <code>y_val</code> output value, for tasks like property prediction</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="TextDataset" class="doc_header"><code>class</code> <code>TextDataset</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L345" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>TextDataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <a href="/mrl/dataloaders.html#BaseDataset"><code>BaseDataset</code></a></p>
</blockquote>
<p>TextDataset - base dataset for language modes</p>
<p>Inputs:</p>

<pre><code>`smiles` - list[str], list of text sequences

`vocab` - Vocab, vocabuary for tokenization/numericaization

`collate_function` - batch collate function. If None, defauts to [`lm_collate`](/mrl/dataloaders.html#lm_collate)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;files/smiles.csv&#39;</span><span class="p">)</span>
<span class="n">vocab</span> <span class="o">=</span> <span class="n">CharacterVocab</span><span class="p">(</span><span class="n">SMILES_CHAR_VOCAB</span><span class="p">)</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">TextDataset</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">vocab</span><span class="p">)</span>
<span class="n">dl</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">dataloader</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dl</span><span class="p">))</span>

<span class="k">assert</span> <span class="p">(</span><span class="n">x</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="TextPredictionDataset" class="doc_header"><code>class</code> <code>TextPredictionDataset</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L387" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>TextPredictionDataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <a href="/mrl/dataloaders.html#TextDataset"><code>TextDataset</code></a></p>
</blockquote>
<p>TextDataset - base dataset for predicting from text strings</p>
<p>Inputs:</p>

<pre><code>`smiles` - list[str], list of text sequences

`y_vals` - list[int, float], list of paired output values

`vocab` - Vocab, vocabuary for tokenization/numericaization

`collate_function` - batch collate function. If None, defauts to [`sequence_prediction_collate`](/mrl/dataloaders.html#sequence_prediction_collate)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">TextPredictionDataset</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">vocab</span><span class="p">)</span>
<span class="n">dl</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">dataloader</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dl</span><span class="p">))</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">float</span><span class="p">())</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Vector-Datasets">Vector Datasets<a class="anchor-link" href="#Vector-Datasets"> </a></h2><p>Another common dataset framework is where we are dealing with vectors derived from a molecule. This could be a vector of properties, fingerprints, or any task where a molecule-derived vector is needed.</p>
<p><a href="/mrl/dataloaders.html#Vector_Dataset"><code>Vector_Dataset</code></a> is a base dataset that simply returns the molecule derived vector</p>
<p><a href="/mrl/dataloaders.html#Vec_Recon_Dataset"><code>Vec_Recon_Dataset</code></a> returns the molecule derived vector and tokenized SMILES strings. This is used for tasks like generating compounds based on an input vector or fingerprint</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Vector_Dataset" class="doc_header"><code>class</code> <code>Vector_Dataset</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L430" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Vector_Dataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <a href="/mrl/dataloaders.html#BaseDataset"><code>BaseDataset</code></a></p>
</blockquote>
<p>Vector_Dataset - base dataset for molecule-derived vectors</p>
<p>Inputs:</p>

<pre><code>`smiles` - list[str], list of text sequences

`mol_function` - function to convert smiles to a vector

`collate_function` - batch collate function. If None, defauts to [`vector_collate`](/mrl/dataloaders.html#vector_collate)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">mrl.chem</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">smile_to_props</span><span class="p">(</span><span class="n">smile</span><span class="p">):</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">to_mol</span><span class="p">(</span><span class="n">smile</span><span class="p">)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">molwt</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">tpsa</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">n_rings</span> <span class="o">=</span> <span class="n">rings</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">heavy_atoms</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">weight</span><span class="o">/</span><span class="mi">500</span><span class="p">,</span> <span class="n">ps</span><span class="o">/</span><span class="mi">100</span><span class="p">,</span> <span class="n">n_rings</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_atoms</span><span class="o">/</span><span class="mi">20</span><span class="p">])</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">Vector_Dataset</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">smile_to_props</span><span class="p">)</span>
<span class="n">dl</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">dataloader</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dl</span><span class="p">))</span>
<span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>//anaconda3/envs/mrl/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::shared_ptr&lt;RDKit::FilterCatalogEntry const&gt; already registered; second conversion method ignored.
  return f(*args, **kwds)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Vec_Recon_Dataset" class="doc_header"><code>class</code> <code>Vec_Recon_Dataset</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L472" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Vec_Recon_Dataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <a href="/mrl/dataloaders.html#Vector_Dataset"><code>Vector_Dataset</code></a></p>
</blockquote>
<p>Vec_Recon_Dataset - base dataset for predicting smiles from molecule-derived vectors</p>
<p>Inputs:</p>

<pre><code>`smiles` - list[str], list of text sequences

`vocab` - Vocab, vocabuary for tokenization/numericaization

`mol_function` - function to convert smiles to fingerprints

`collate_function` - batch collate function. If None, defauts to [`vector_reconstruction_collate`](/mrl/dataloaders.html#vector_reconstruction_collate)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">Vec_Recon_Dataset</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">vocab</span><span class="p">,</span> <span class="n">ECFP6</span><span class="p">)</span>
<span class="n">dl</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">dataloader</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dl</span><span class="p">))</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
<span class="k">assert</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Vec_Prediction_Dataset" class="doc_header"><code>class</code> <code>Vec_Prediction_Dataset</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/dataloaders.py#L519" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Vec_Prediction_Dataset</code>(<strong>*<code>args</code></strong>, <strong>**<code>kwds</code></strong>) :: <a href="/mrl/dataloaders.html#Vector_Dataset"><code>Vector_Dataset</code></a></p>
</blockquote>
<p>Vec_Prediction_Dataset - base dataset for predicting y_vals from molecule derived vectors</p>
<p>Inputs:</p>

<pre><code>`smiles` - list[str], list of text sequences

`y_vals` - list[int, float], list of paired output values

`mol_function` - function to convert smiles to fingerprints

`collate_function` - batch collate function. If None, defauts to [`vector_prediction_collate`](/mrl/dataloaders.html#vector_prediction_collate)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">Vec_Prediction_Dataset</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span><span class="p">],</span> <span class="n">ECFP6</span><span class="p">)</span>
<span class="n">dl</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">dataloader</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dl</span><span class="p">))</span>
<span class="k">assert</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

