---

title: Reward

keywords: fastai
sidebar: home_sidebar

summary: "Rewards - non-differentiable scores for samples"
description: "Rewards - non-differentiable scores for samples"
nb_path: "nbs/21_reward.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/21_reward.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Overview">Overview<a class="anchor-link" href="#Overview"> </a></h2><p>Rewards are non-differentiable score functions for evaluating samples. Rewards should generally follow the format <code>reward = reward_function(sample)</code></p>
<p>Rewards in MRL occupy five events in the fit loop:</p>
<ul>
<li><code>before_compute_reward</code> - set up necessary values prior to reward calculation (if needed)</li>
<li><code>compute_reward</code> - compute reward</li>
<li><code>after_compute_reward</code> - compute metrics (if needed)</li>
<li><code>reward_modification</code> - adjust rewards</li>
<li><code>after_reward_modification</code> - compute metrics (if needed)</li>
</ul>
<h3 id="Rewards-vs-Reward-Modifications">Rewards vs Reward Modifications<a class="anchor-link" href="#Rewards-vs-Reward-Modifications"> </a></h3><p>MRl breaks rewards up into two phases - rewards and reward modifications. The difference between the two phases is that <strong>reward</strong> values are saved in the batch log, while <strong>reward_modifications</strong> are not.</p>
<p>In this framework, rewards are absolute scores for samples that are used to evaluate the sample relative to all other samples in the log. Reward modifications are transient scores that depend on the current training context.</p>
<p>A reward modification might be something like adding a score bonus to compounds the first time they are created during training to encourage diversity, or penalizing compounds if they appear more than 3 times in the last 5 batches. These types of reward modifications allow us to influence the behavior of the generative model without having these scores effect the true rewards we save in the log</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reward-Class">Reward Class<a class="anchor-link" href="#Reward-Class"> </a></h2><p>As mentioned above, rewards generally follow the format <code>reward = reward_function(sample)</code>. The <a href="/mrl/reward#Reward"><code>Reward</code></a> class acts as a wrapper around the <code>reward_function</code> to provide some convenience functions. <a href="/mrl/reward#Reward"><code>Reward</code></a> maintains a lookup table of <code>sample : reward</code> values to avoid repeat computation. <a href="/mrl/reward#Reward"><code>Reward</code></a> handles batching novel samples (ie not in the lookup table), sending them to <code>reward_function</code>, and merging the outputs with the lookup table values.</p>
<p>Creating a custom reward involves creating a callable function or object that can take in a list of <code>samples</code> and return a list of reward values. For example:</p>

<pre><code>class MyRewardFunction():
    def __call__(self, samples):
        rewards = self.do_reward_calculation(samples)
        return rewards

reward_function = MyRewardFunction()
reward = Reward(reward_function, weight=0.5, log=True)</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Reward" class="doc_header"><code>class</code> <code>Reward</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/train/reward.py#L16" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Reward</code>(<strong><code>reward_function</code></strong>, <strong><code>weight</code></strong>=<em><code>1</code></em>, <strong><code>bs</code></strong>=<em><code>None</code></em>, <strong><code>log</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Reward - wrapper for <code>reward_function</code>. Handles batching
and value lookup</p>
<p>Inputs:</p>
<ul>
<li><p><code>reward_function Callable</code>: function with the format
<code>rewards = reward_function(samples)</code></p>
</li>
<li><p><code>weight float</code>: weight to scale rewards</p>
</li>
<li><p><code>bs Optional[int]</code>: if given, samples will be batched into
chunks of size <code>bs</code> and sent to <code>reward_function</code> as batches</p>
</li>
<li><p><code>log bool</code>: if True, keeps aa lookup table of
<code>sample : reward</code> values to avoid repeat computation</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reward-Callback">Reward Callback<a class="anchor-link" href="#Reward-Callback"> </a></h2><p><a href="/mrl/reward#RewardCallback"><code>RewardCallback</code></a> handles it loop integration and metric logging for a given <a href="/mrl/reward#Reward"><code>Reward</code></a></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RewardCallback" class="doc_header"><code>class</code> <code>RewardCallback</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/train/reward.py#L106" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RewardCallback</code>(<strong><code>reward</code></strong>, <strong><code>name</code></strong>, <strong><code>sample_name</code></strong>=<em><code>'samples'</code></em>, <strong><code>order</code></strong>=<em><code>10</code></em>, <strong><code>track</code></strong>=<em><code>True</code></em>) :: <a href="/mrl/callback_core#Callback"><code>Callback</code></a></p>
</blockquote>
<p>RewardCallback - callback wrapper for <a href="/mrl/reward#Reward"><code>Reward</code></a>
used during <code>compute_reward</code> event</p>
<p>Inputs:</p>
<ul>
<li><p><code>reward Reward</code>: reward to use</p>
</li>
<li><p><code>name str</code>: reward name</p>
</li>
<li><p><code>sample_name str</code>: sample name to grab from
<a href="/mrl/callback_core#BatchState"><code>BatchState</code></a> to send to <code>reward</code></p>
</li>
<li><p><code>order int</code>: callback order</p>
</li>
<li><p><code>track bool</code>: if metrics should be tracked
from this callback</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>For greater flexibility, <a href="/mrl/reward#GenericRewardCallback"><code>GenericRewardCallback</code></a> will pass the entire <a href="/mrl/callback_core#BatchState"><code>BatchState</code></a> to <code>reward</code></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="GenericRewardCallback" class="doc_header"><code>class</code> <code>GenericRewardCallback</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/train/reward.py#L157" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>GenericRewardCallback</code>(<strong><code>reward</code></strong>, <strong><code>name</code></strong>, <strong><code>order</code></strong>=<em><code>10</code></em>, <strong><code>track</code></strong>=<em><code>True</code></em>) :: <a href="/mrl/reward#RewardCallback"><code>RewardCallback</code></a></p>
</blockquote>
<p>GenericRewardCallback - generic reward
wrapper</p>
<p>Inputs:</p>
<ul>
<li><p><code>reward Callable</code>: reward function. Reward
will be passed the entire batch state</p>
</li>
<li><p><code>name str</code>: reward name</p>
</li>
<li><p><code>order int</code>: callback order</p>
</li>
<li><p><code>track bool</code>: if metrics should be tracked
from this callback</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Reward-Modification">Reward Modification<a class="anchor-link" href="#Reward-Modification"> </a></h2><p>As discussed above, reward modifications apply changes to rewards based on some sort of transient batch context. These are rewards that will influence a given batch, but not the logged rewards.</p>
<p>Reward modifications should update the value <a href="/mrl/callback_core#BatchState.rewards_final"><code>BatchState.rewards_final</code></a></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RewardModification" class="doc_header"><code>class</code> <code>RewardModification</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/train/callback.py#L255" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RewardModification</code>() :: <a href="/mrl/callback_core#Event"><code>Event</code></a></p>
</blockquote>
<p>RewardModification</p>
<p>This event is used to modify rewards before they
are used to compute the model's loss. Reward modifications
encompass changes to rewards in the context of the current
training cycle. These are things like "give a score bonus
to new samples that havent't been seen before" or "penalize
the score of samples that have occurred in the last 5 batches".</p>
<p>These types of modifications are kept separate from the core
reward for logging purposes. Samples are logged with their
respective rewards. These logged scores are referenced later
when samples are drawn from the log. This means we need the
logged score to be independent from "batch context" type scores</p>
<p>All reward modifications should be
applied to <code>self.environmemnt.batch_state.rewards</code></p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NoveltyReward" class="doc_header"><code>class</code> <code>NoveltyReward</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/train/reward.py#L246" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NoveltyReward</code>(<strong><code>weight</code></strong>=<em><code>1.0</code></em>, <strong><code>track</code></strong>=<em><code>True</code></em>) :: <a href="/mrl/callback_core#Callback"><code>Callback</code></a></p>
</blockquote>
<p>NoveltyReward - gives a reward bonus
for new samples. Rewards are given a
bonus of <code>weight</code></p>
<p>Inputs:</p>
<ul>
<li><p><code>weight float</code>: novelty score weight</p>
</li>
<li><p><code>track bool</code>: if metrics should be tracked
from this callback</p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Contrastive-Reward">Contrastive Reward<a class="anchor-link" href="#Contrastive-Reward"> </a></h2><p>Similar to <a href="/mrl/template_callback#ContrastiveTemplate"><code>ContrastiveTemplate</code></a>, <a href="/mrl/reward#ContrastiveReward"><code>ContrastiveReward</code></a> provides a wrapper around a <a href="/mrl/reward#RewardCallback"><code>RewardCallback</code></a> to adapt it for the task of contrastive generation.</p>
<p>For contrastive generation, we want the model to ingest a source sample and produce a target sample that receives a higher reward than the source sample. <a href="/mrl/reward#ContrastiveReward"><code>ContrastiveReward</code></a> takes some <code>base_reward</code> and computes the values of that base reward for both source and target samples, and returns the difference between those rewards.</p>
<p>Optionally, the contrastive reward will scale the relative reward based on a given <code>max_score</code> (ie <code>reward = (target_reward - source_reward)/(max_reward - source_reward)</code>). This scales the contrastive reward relative to the maximum possible reward</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ContrastiveReward" class="doc_header"><code>class</code> <code>ContrastiveReward</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/train/reward.py#L290" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ContrastiveReward</code>(<strong><code>base_reward</code></strong>, <strong><code>max_score</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/reward#RewardCallback"><code>RewardCallback</code></a></p>
</blockquote>
<p>ContrastiveReward - contrastive wrapper for
reward callbacks</p>
<p>Inputs:</p>
<ul>
<li><p><code>base_reward RewardCallback</code>: base reward callback</p>
</li>
<li><p><code>max_score Optional[float]</code>: maximum possible score.
If given, contrastive rewards are scaled following
<code>reward = (target_reward - source_reward)/(max_reward - source_reward)</code></p>
</li>
</ul>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

