---

title: Blocks

keywords: fastai
sidebar: home_sidebar

summary: "Blocks are used for advanced templating where different templates are applied to different sections of the molecule"
description: "Blocks are used for advanced templating where different templates are applied to different sections of the molecule"
nb_path: "nbs/04_template.blocks.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/04_template.blocks.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/home/dmai/miniconda3/envs/mrl/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::shared_ptr&lt;RDKit::FilterCatalogEntry const&gt; already registered; second conversion method ignored.
  return f(*args, **kwds)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Overview">Overview<a class="anchor-link" href="#Overview"> </a></h2><p>Tempates define a chemical space using a set of hard and soft fiters to evaluate a molecule. For greater control, we may wish to apply different templates to different parts of the molecule. With the <a href="/mrl/template.blocks#Block"><code>Block</code></a> and <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a> classes and some modifications to how we represent SMILES strings, we can do this.</p>
<p>For a detailed example of using Blocks, see the <a href="/mrl/tutorials.template.advanced.html">Block Tutorial</a> page</p>
<h3 id="Motivating-Example:-R-group-Optimization">Motivating Example: R-group Optimization<a class="anchor-link" href="#Motivating-Example:-R-group-Optimization"> </a></h3><p>Say we have a compound of the form <code>R1-scaffold-R2</code>, where the scaffold is a defined structure. We want to run a generative screen on the two R-groups while keeping the scaffold constant. We also have preferences on the chemical structures present at each R-group. We want <code>R1</code> to contain at least 1 ring, and we want <code>R2</code> to have no rings.</p>
<p>One way to approach this would be to build a dataset of compounds with the format <code>R1-scaffold-R2</code> where all <code>R1</code> and <code>R2</code> structures conform to our desired properties. We would then train a generative model on this dataset and run a standard generative screen. However, this runs the risk of generated compounds deviating from our desired chemotype. This means we need to create a template that enforces the <code>R1-scaffold-R2</code> chemotype with our stated constraints on <code>R1</code> and <code>R2</code>.</p>
<p>This leads to the problem of factoring arbitrary chemical structures into our <code>R1-scaffold-R2</code>, with all sorts of nasty problems and edge cases cropping up if the model deviates from this chemotype during training. Doing so would require defining a wide variety of SMARTS strings and fragmentation rules to deal with matching arbitry compounds to the <code>R1-scaffold-R2</code> chemotype.</p>
<p>Comparatively, it is much easier to generate a string of molecular fragments and assemble them into a single compound. Rather than generating compounds of the form <code>R1-scaffold-R2</code>, we generate fragments of the form <code>*R1.*scaffold*.*R2</code>. Since our scaffold is defined, we can simplify this to generating <code>*R1.*R2</code>, which is helpful because shorter sequence spaces are easier to learn. In doing so, we have embedded our chemotype prior into the geneation process.</p>
<p>Now we can evaluate and assemble compounds to compare them to our desired constraints. We create different templates for <code>R1</code>, <code>R2</code> and the full compound <code>R1-scaffold-R2</code>.</p>
<p>The model generates some sequence of the form <code>*R1.*R2</code>. We split this into <code>*R1</code> and <code>*R2</code>, and evaluate each R group with their respective template. Then we add in the scaffold, fuse the fragments into the full molecule, and evaluate the full molecule template.</p>
<p>When we generate and evauate compounds in this way, we can build in a strong guarantee that compounds passing this tiered templating process will conform to our specified chemotype.</p>
<h3 id="The-Block-Class">The Block Class<a class="anchor-link" href="#The-Block-Class"> </a></h3><p>The process described above is implemented using the <a href="/mrl/template.blocks#Block"><code>Block</code></a> class. A block is a general abstraction for a chunk of a molecule. The <a href="/mrl/template.blocks#Block"><code>Block</code></a> class holds a <a href="/mrl/template.template#Template"><code>Template</code></a> describing desired molecular properties and additional information specifying how the block links to other blocks.</p>
<p>Blocks are assembled into a tree structure, with some blocks nested within other blocks. For the above example, we would have four blocks in total. We would have two <a href="/mrl/template.blocks#MolBlock"><code>MolBlock</code></a> blocks for <code>R1</code> and <code>R2</code> and a <a href="/mrl/template.blocks#ConstantMolBlock"><code>ConstantMolBlock</code></a> for the pre-defined scaffold. The block structure would look like this:</p>

<pre><code>Block tree:

Block 1 - full molecule
    Block 2 - scaffold (constant)
    Block 3 - R1 + R1 Template
    Block 4 - R2 + R2 Template</code></pre>
<p>If we passed our <code>*R1.*R2</code> generated sequence to the head block, Block 1, the sequence would be broken down into fragments and routed to subblocks. <code>R1</code> would be screened against the R1 Template in Block 3. <code>R2</code> would be screened against the R2 template in Block 4. Then <code>R1</code> and <code>R2</code> would be merged with the constant scaffold in Block 2 to create the full <code>R1-scaffold-R2</code> compound. Then the full compound would be screened by the full molecule template in Block 1.</p>
<h3 id="Fragment-Routing">Fragment Routing<a class="anchor-link" href="#Fragment-Routing"> </a></h3><p>One important detail is how fragments are routed to different blocks. If the model generates <code>*R1.*R2</code>, how do we know that <code>R1</code> should be routed to one block and <code>R2</code> should be routed to a different block? We specify block assignments using isotope and atom map numbers on the wildcard atoms.</p>
<p>Map numbers are used to determine which atoms are fused together. If we had a fragment sequence <code>*X.*Y*.*Z</code>, we don't know how to assemble the fragments. If we add atom map numbers to get <code>[*:2]X.[*:1]Y[*:2].[*:1]Z</code>, then we can definitely assemble the sequence into <code>[*:2]X.[*:1]Y[*:2].[*:1]Z &gt;&gt; Z[*:1].[*:1]Y[*:2].[*:2]X &gt;&gt; Z-Y-X</code>.</p>
<p>Isotope numbers are used to differentiate fragments with the same map number. Say we have a fragment sequence of <code>[*:1]X.[*:1]Y</code>, and we want <code>X</code> to be evaluated by one template and <code>Y</code> to be evaluated by another. We need a way of uniquely distinguishing one fragment from another. By adding isotopes to wildcards in addition to map numbers, ie <code>[*:1]X &gt;&gt; [1*:1]X</code>, we can uniquely match fragments to blocks.</p>
<p>Going back to the previous example, our framework of <code>*R1.*scaffold*.*R2</code> would become <code>[2*:1]R1.[1*:1]scaffold[1*:2].[2*:2]R2</code>, and our generative model would create sequences of the form <code>[2*:1]R1.[2*:2]R2</code>. This is easilly implemented by adding new tokens to the vocabulary of our generative model.</p>
<p>These links would be specified in the block structure:</p>

<pre><code>Block tree:

Block 1 - full molecule, links=[]
    Block 2 - scaffold (constant), links=['[1*:1]', '[1*:2]']
    Block 3 - R1 + R1 Template, links=['[2*:1]']
    Block 4 - R2 + R2 Template, links=['[2*:2]']</code></pre>
<p>When analyzing a fragment sequence, a block will extract the isotope/map number links of <code>{isotope}*:{map_num}</code> from each fragment. The links present in a fragment are compared to the links specified in the Block, as well as any subblocks contained within the block.</p>
<h3 id="Fragment-Routing-Convention">Fragment Routing Convention<a class="anchor-link" href="#Fragment-Routing-Convention"> </a></h3><p>Wildcards should be expressed as <code>[{isotope}*:{map_number}]</code>. The <code>isotope</code> value sould be <code>1</code> or <code>2</code>. <code>0</code> should not be used as RDKit canonicalization removes zero isotope values from wildcards.</p>
<h3 id="The-BlockTemplate-Class">The BlockTemplate Class<a class="anchor-link" href="#The-BlockTemplate-Class"> </a></h3><p>Once the block tree is assembled, it can be used to create a <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a>. The <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a> class is a wrapper for a series of nested <code>Blocks</code> designed to behave like the <a href="/mrl/template.template#Template"><code>Template</code></a> class. <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a> has the same <code>__call__</code> API as <a href="/mrl/template.template#Template"><code>Template</code></a>, and provides saving/loading functions and data logging, as well as easy access to nodes via unnested lists and dictionaries.</p>
<h3 id="Code-Example">Code Example<a class="anchor-link" href="#Code-Example"> </a></h3><p>For the <code>R1-scaffold-R2</code> example, setting up the blocks would look something like this</p>

<pre><code>r1_template = Template(r1_hard_filters, r1_soft_filters)
r1_links = ['2*:1']
r1_block = MolBlock(r1_template, r1_links, name='r1')

r2_template = Template(r2_hard_filters, r2_soft_filters)
r2_links = ['2*:2']
r2_block = MolBlock(r2_template, r2_links, name='r2')

scaffold_links = ['1*:1', '1*:2']
scaffold_block = ConstantMolBlock(scaffold_smile, name='scaffold', links=scaffold_links)

full_molecule_template = Template(full_hard_filters, full_soft_filters)
main_block = MolBlock(full_molecule_template, [], name='full_molecule', subblocks=[r1_block, r2_block, scaffold_block])

block_template = BlockTemplate(main_block)</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Block" class="doc_header"><code>class</code> <code>Block</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L15" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Block</code>(<strong><code>template</code></strong>, <strong><code>links</code></strong>, <strong><code>name</code></strong>, <strong><code>subblocks</code></strong>=<em><code>[]</code></em>)</p>
</blockquote>
<p>Block - base class for Blocks</p>
<p>Inputs:</p>

<pre><code>`template` - [`Template`](/mrl/template.template#Template) subclass

`links` - list, defines links between this block and other blocks

`name` - str, block name

`subblocks` - list, list of [`Block`](/mrl/template.blocks#Block) classes nested within this block</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MolBlock" class="doc_header"><code>class</code> <code>MolBlock</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L140" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>MolBlock</code>(<strong><code>template</code></strong>, <strong><code>links</code></strong>, <strong><code>name</code></strong>, <strong><code>subblocks</code></strong>=<em><code>[]</code></em>) :: <a href="/mrl/template.blocks#Block"><code>Block</code></a></p>
</blockquote>
<p>MolBlock - <a href="/mrl/template.blocks#Block"><code>Block</code></a> subclass specific to working with smiles strings. This class expects
links between SMILES fragments to be wildcard atoms of the form <code>{isotope}*:{map_number}</code>.
Note that '0' should not be used as an isotope number because RDKit removes '0' isotopes from
SMILES strings automatically.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="MolBlock.recurse_fragments" class="doc_header"><code>MolBlock.recurse_fragments</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L259" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>MolBlock.recurse_fragments</code>(<strong><code>fragments</code></strong>, <strong><code>add_constant</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>recurse_fragments - recursively evlauates <code>fragments</code> against <code>self.template</code>
and all blocks in <code>self.subblocks</code></p>
<p>Inputs:</p>

<pre><code>`fragments` - fragments to process. Can either be a single string of the form `'f1.f2.f3'`
or a list of the form `['f1','f2','f3']`

`add_constant` - bool, if True, constant sequences in any [`ConstantBlock`](/mrl/template.blocks#ConstantBlock) subclasses
are added to `fragments` during evaluation. Should be `True` if constant sequences are
missing from `fragments` or False if they are present

</code></pre>
<p>Returns:</p>

<pre><code>`fused` - str, fragments fused at this stage

`total_pass` - bool, True if `fragments` passed all subblock templates and `fused` passed
`self.template`

`total_score` - float, sum of scores from `self.template.soft_filters` and subblock template soft filters

`output_dicts` - list, list of dictionaries holding information from this block and subblocks

</code></pre>
<p>Recurse fragments works in the following way:</p>

<pre><code>1. Fragments are decomposed based on `self.decompose_fragments`
2. Fragments are routed to subblocks if present using `self.match_fragment_recursive`
3. Any fragments matching a subblock are first evaluated by that subblock's template
4. If `add_constant=True`, constant sequences from any [`ConstantBlock`](/mrl/template.blocks#ConstantBlock) subblocks are added
5. Fragments are joined and fused using `self.join_fragments` and `self.fuse_fragments`
6. The fused fragments are processed by `self.eval_mol`</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ConstantBlock" class="doc_header"><code>class</code> <code>ConstantBlock</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L352" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ConstantBlock</code>(<strong><code>constant</code></strong>, <strong><code>name</code></strong>)</p>
</blockquote>
<p>ConstantBlock - base block class for constant sequence</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ConstantMolBlock" class="doc_header"><code>class</code> <code>ConstantMolBlock</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L382" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ConstantMolBlock</code>(<strong><code>smile</code></strong>, <strong><code>name</code></strong>, <strong><code>links</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/template.blocks#ConstantBlock"><code>ConstantBlock</code></a></p>
</blockquote>
<p>ConstantMolBlock - constant block for SMILES sequence</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BlockTemplate" class="doc_header"><code>class</code> <code>BlockTemplate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L410" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BlockTemplate</code>(<strong><code>head_block</code></strong>)</p>
</blockquote>
<p>BlockTemplate - base class for handling nested blocks. Takes care of running fragment strings and logging outputs</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="RGroupBlockTemplate" class="doc_header"><code>class</code> <code>RGroupBlockTemplate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L576" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>RGroupBlockTemplate</code>(<strong><code>base_smile</code></strong>, <strong><code>rgroup_template</code></strong>, <strong><code>full_molecule_template</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a></p>
</blockquote>
<p>RGroupBlockTemplate - block template for r-group screening</p>
<p>Inputs:</p>

<pre><code>`base_smile` - str, base smile to attach r-group to. Should have a single unmapped wildcard
atom, ie `*CCCC`

`rgroup_template` - [`Template`](/mrl/template.template#Template), template for screening r-groups

`full_molecule_template` - [`Template`](/mrl/template.template#Template), None. Optional template for full molecule</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="DoubleRGroupBlockTemplate" class="doc_header"><code>class</code> <code>DoubleRGroupBlockTemplate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L612" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>DoubleRGroupBlockTemplate</code>(<strong><code>base_smile</code></strong>, <strong><code>r1_template</code></strong>, <strong><code>r2_template</code></strong>, <strong><code>full_molecule_template</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a></p>
</blockquote>
<p>DoubleRGroupBlockTemplate - block template for screening two r-groups</p>
<p>Inputs:</p>

<pre><code>`base_smile` - str, base smile to attach r-group to. Should have two mapped wildcard atoms,
ie `'c1nc2c([1*:1])cncc2cc1[1*:2]'`. Rgroup1 will be fused to wildcard `1*:1` and Rgroup 2
will be fused to wildcard `1*:2`

`r1_template` - [`Template`](/mrl/template.template#Template), template for screening rgroup 1

`r2_template` - [`Template`](/mrl/template.template#Template), template for screening rgroup 2

`full_molecule_template` - [`Template`](/mrl/template.template#Template), None. Optional template for full molecule</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="LinkerBlockTemplate" class="doc_header"><code>class</code> <code>LinkerBlockTemplate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L649" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>LinkerBlockTemplate</code>(<strong><code>smile1</code></strong>, <strong><code>smile2</code></strong>, <strong><code>linker_template</code></strong>, <strong><code>full_molecule_template</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a></p>
</blockquote>
<p>LinkerBlockTemplate - block template for screening linkers</p>
<p>Inputs:</p>

<pre><code>`smile1` - str, left-side linker attachment. Should have a single unmapped wildcard,
ie `*CCCC`

`smile2` - str, right-side linker attachment. Should have a single unmapped wildcard,
ie `*CCCC`

`linker_template` - [`Template`](/mrl/template.template#Template), template for screening the linker

`full_molecule_template` - [`Template`](/mrl/template.template#Template), None. Optional template for full molecule</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ScaffoldBlockTemplate" class="doc_header"><code>class</code> <code>ScaffoldBlockTemplate</code><a href="https://github.com/DarkMatterAI/mrl/tree/main/mrl/templates/blocks.py#L697" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ScaffoldBlockTemplate</code>(<strong><code>attachments</code></strong>, <strong><code>scaffold_template</code></strong>, <strong><code>full_molecule_template</code></strong>=<em><code>None</code></em>) :: <a href="/mrl/template.blocks#BlockTemplate"><code>BlockTemplate</code></a></p>
</blockquote>
<p>ScaffoldBlockTemplate - block template for screening scaffolds or rings with multiple attachments</p>
<p>Inputs:</p>

<pre><code>`attachments` - list, list of mapped attachments. All attachments should have a single wildcard
atom mapped following the format `[{isotope}*:{map_num}]`, ie `['[1:*1]CC', '[1:*2]CCC']`

`scaffold_template` - [`Template`](/mrl/template.template#Template), template for screening the scaffold

`full_molecule_template` - [`Template`](/mrl/template.template#Template), None. Optional template for full molecule</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># scaffod</span>
<span class="n">scaffold_smile</span> <span class="o">=</span> <span class="s1">&#39;c1nc2c([1*:2])cncc2cc1[1*:1]&#39;</span>
<span class="n">scaffold_block</span> <span class="o">=</span> <span class="n">ConstantMolBlock</span><span class="p">(</span><span class="n">scaffold_smile</span><span class="p">,</span> <span class="s1">&#39;scaffold&#39;</span><span class="p">)</span>

<span class="c1"># R1, must have ring, be between 50-250 g/mol. must have 1 ring. ideally less thn 100-200 g/mol</span>

<span class="n">r1_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">250</span><span class="p">),</span>
                     <span class="n">RingFilter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                    <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
                    <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                    <span class="p">)</span>

<span class="c1"># R2, must have no rings, be between 0-200 g/mol. must have 0 rings. ideally less thn 50-150 g/mol</span>

<span class="n">r2_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
                     <span class="n">RingFilter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
                    <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                    <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                    <span class="p">)</span>

<span class="c1"># full compound, must be between 200 and 550 g/mol</span>

<span class="n">full_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">550</span><span class="p">)],</span>
                    <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="n">block_template</span> <span class="o">=</span> <span class="n">DoubleRGroupBlockTemplate</span><span class="p">(</span><span class="n">scaffold_smile</span><span class="p">,</span> <span class="n">r1_template</span><span class="p">,</span> <span class="n">r2_template</span><span class="p">,</span> <span class="n">full_template</span><span class="p">)</span>

<span class="n">frag_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cc1c(CS(C)(=O)=O)cccc1NC(=O)N[2*:1].O=C(Cl)[2*:2]&#39;</span><span class="p">,</span>
             <span class="s1">&#39;CC(C)Oc1ccc(C[NH2+][2*:1])cc1.CC(C)(CCO)C[2*:2]&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Cc1ccc(NC(=O)[2*:1])cc1S(C)(=O)=O.CC(C)CCNC(=O)N[2*:2]&#39;</span><span class="p">,</span>
             <span class="s1">&#39;NS(=O)(=O)Cc1cccc([2*:1])c1.CC(C)(O)CC[2*:2]&#39;</span><span class="p">]</span>

<span class="n">fused</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cc1c(CS(C)(=O)=O)cccc1NC(=O)Nc1cnc2c(C(=O)Cl)cncc2c1&#39;</span><span class="p">,</span>
     <span class="s1">&#39;CC(C)Oc1ccc(C[NH2+]c2cnc3c(CC(C)(C)CCO)cncc3c2)cc1&#39;</span><span class="p">,</span>
     <span class="s1">&#39;Cc1ccc(NC(=O)c2cnc3c(NC(=O)NCCC(C)C)cncc3c2)cc1S(C)(=O)=O&#39;</span><span class="p">,</span>
     <span class="s1">&#39;CC(C)(O)CCc1cncc2cc(-c3cccc(CS(N)(=O)=O)c3)cnc12&#39;</span><span class="p">]</span>

<span class="n">outputs</span> <span class="o">=</span> <span class="n">block_template</span><span class="o">.</span><span class="n">recurse_fragments</span><span class="p">(</span><span class="n">frag_strings</span><span class="p">,</span> <span class="n">add_constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">assert</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">==</span> <span class="n">fused</span>
<span class="k">assert</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">block_template</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>Block Template
	Block full_molecule: []
		Template
			Hard Filter:
				molwt (200, 550)
			Soft Filter:
				
	
		Constant Block: c1nc2c([1*:2])cncc2cc1[1*:1]
		Block r1: [&#39;2*:1&#39;]
			Template
				Hard Filter:
					molwt (50, 250)
					rings (1, 1)
				Soft Filter:
					molwt (100, 200)
		Block r2: [&#39;2*:2&#39;]
			Template
				Hard Filter:
					molwt (0, 200)
					rings (None, 0)
				Soft Filter:
					molwt (50, 150)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># one constant and one variabe</span>

<span class="c1"># scaffod</span>
<span class="n">scaffold_smile</span> <span class="o">=</span> <span class="s1">&#39;c1nc2c([1*:2])cncc2cc1[1*:1]&#39;</span>
<span class="n">scaffold_block</span> <span class="o">=</span> <span class="n">ConstantMolBlock</span><span class="p">(</span><span class="n">scaffold_smile</span><span class="p">,</span> <span class="s1">&#39;scaffold&#39;</span><span class="p">)</span>

<span class="c1"># R1 has 3 groups - constant carbonyl, variable ring, variabe ring attachment</span>

<span class="n">r1_carbonyl_block</span> <span class="o">=</span> <span class="n">ConstantMolBlock</span><span class="p">(</span><span class="s1">&#39;C(O)(=O)[1*:4]&#39;</span><span class="p">,</span> <span class="s1">&#39;carbonyl&#39;</span><span class="p">)</span>

<span class="n">r1_ring_substitution_tempate</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                                        <span class="p">[</span><span class="n">RotBondFilter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
                                         <span class="n">RingFilter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
                                        <span class="p">[</span><span class="n">RotBondFilter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                                        <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                                        <span class="p">)</span>

<span class="n">r1_ring_substitution_block</span> <span class="o">=</span> <span class="n">MolBlock</span><span class="p">(</span><span class="n">r1_ring_substitution_tempate</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;1*:3&#39;</span><span class="p">],</span> <span class="s1">&#39;r1 ring substitution&#39;</span><span class="p">)</span>

<span class="n">r1_ring_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">RingFilter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                             <span class="n">RotBondFilter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                            <span class="p">[</span><span class="n">RingFilter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                            <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                            <span class="p">)</span>

<span class="n">r1_ring_block</span> <span class="o">=</span> <span class="n">MolBlock</span><span class="p">(</span><span class="n">r1_ring_template</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;2*:3&#39;</span><span class="p">,</span> <span class="s1">&#39;2*:4&#39;</span><span class="p">,</span> <span class="s1">&#39;2*:2&#39;</span><span class="p">],</span> <span class="s1">&#39;r1_ring&#39;</span><span class="p">)</span>


<span class="n">r1_full_group_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">350</span><span class="p">)],</span>
                            <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                            <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                            <span class="p">)</span>

<span class="n">r1_block</span> <span class="o">=</span> <span class="n">MolBlock</span><span class="p">(</span><span class="n">r1_full_group_template</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;2*:2&#39;</span><span class="p">],</span> <span class="s1">&#39;r1_full&#39;</span><span class="p">,</span> 
                     <span class="n">subblocks</span><span class="o">=</span><span class="p">[</span><span class="n">r1_carbonyl_block</span><span class="p">,</span> <span class="n">r1_ring_substitution_block</span><span class="p">,</span> <span class="n">r1_ring_block</span><span class="p">])</span>


<span class="c1"># R1, must have no rings, be between 0-200 g/mol. must have 0 rings. ideally less thn 50-150 g/mol</span>

<span class="n">r2_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">200</span><span class="p">)],</span>
                        <span class="p">[</span><span class="n">RingFilter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span>
                        <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                        <span class="p">)</span>

<span class="n">r2_block</span> <span class="o">=</span> <span class="n">MolBlock</span><span class="p">(</span><span class="n">r2_template</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;2*:1&#39;</span><span class="p">],</span> <span class="s1">&#39;r2&#39;</span><span class="p">)</span>


<span class="c1"># full compound, must be between 200 and 550 g/mol</span>

<span class="n">full_template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">550</span><span class="p">),</span>
                         <span class="n">StructureFilter</span><span class="p">([</span><span class="s1">&#39;[#6](-[#8])(=[#8])-[*]&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;[#6]1:[#7]:[#6]2:[#6](-[*]):[#6]:[#7]:[#6]:[#6]:2:[#6]:[#6]:1-[*]&#39;</span>
                             <span class="p">],</span> <span class="n">criteria</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">)],</span>
                        <span class="p">[</span><span class="n">MolWtFilter</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                        <span class="n">fail_score</span><span class="o">=-</span><span class="mi">1</span>
                        <span class="p">)</span>

<span class="n">main_block</span> <span class="o">=</span> <span class="n">MolBlock</span><span class="p">(</span><span class="n">full_template</span><span class="p">,</span> <span class="p">[],</span> <span class="s1">&#39;full_molecule&#39;</span><span class="p">,</span> <span class="n">subblocks</span><span class="o">=</span><span class="p">[</span><span class="n">scaffold_block</span><span class="p">,</span> <span class="n">r1_block</span><span class="p">,</span> <span class="n">r2_block</span><span class="p">])</span>

<span class="n">block_template</span> <span class="o">=</span> <span class="n">BlockTemplate</span><span class="p">(</span><span class="n">main_block</span><span class="p">)</span>


<span class="n">frag_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CC(C)(C)SC[1*:3].Cc1cc([2*:3])c([2*:2])n1C[2*:4].Cc1noc(C)c1CO[2*:1]&#39;</span><span class="p">,</span>
 <span class="s1">&#39;C=C(C)C[1*:3].Nc1c(N([2*:2])[2*:4])ncnc1[2*:3].Cc1ccc([2*:1])cc1[N+](=O)[O-]&#39;</span><span class="p">,</span>
 <span class="s1">&#39;CCSCC[1*:3].Cc1ccc(N(C(=O)[2*:4])[2*:3])c([2*:2])c1.Clc1ncccc1N[2*:1]&#39;</span><span class="p">,</span>
 <span class="s1">&#39;C#CCO[1*:3].O=c1n([2*:3])nc([2*:2])n1[2*:4].O=c1ccccn1C[2*:1]&#39;</span><span class="p">]</span>

<span class="n">fused</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cc1noc(C)c1COc1cnc2c(-c3c(CSC(C)(C)C)cc(C)n3CC(=O)O)cncc2c1&#39;</span><span class="p">,</span>
 <span class="s1">&#39;C=C(C)Cc1ncnc(N(C(=O)O)c2cncc3cc(-c4ccc(C)c([N+](=O)[O-])c4)cnc23)c1N&#39;</span><span class="p">,</span>
 <span class="s1">&#39;CCSCCN(C(=O)C(=O)O)c1ccc(C)cc1-c1cncc2cc(Nc3cccnc3Cl)cnc12&#39;</span><span class="p">,</span>
 <span class="s1">&#39;C#CCOn1nc(-c2cncc3cc(Cn4ccccc4=O)cnc23)n(C(=O)O)c1=O&#39;</span><span class="p">]</span>

<span class="n">outputs</span> <span class="o">=</span> <span class="n">block_template</span><span class="o">.</span><span class="n">recurse_fragments</span><span class="p">(</span><span class="n">frag_strings</span><span class="p">,</span> <span class="n">add_constant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="k">assert</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">==</span> <span class="n">fused</span>
<span class="k">assert</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
<span class="k">assert</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">outputs</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[[&#39;CC(C)(C)SC[1*:3].Cc1cc([2*:3])c([2*:2])n1C[2*:4].Cc1noc(C)c1CO[2*:1]&#39;,
  &#39;Cc1noc(C)c1COc1cnc2c(-c3c(CSC(C)(C)C)cc(C)n3CC(=O)O)cncc2c1&#39;,
  True,
  3.0],
 [&#39;C=C(C)C[1*:3].Nc1c(N([2*:2])[2*:4])ncnc1[2*:3].Cc1ccc([2*:1])cc1[N+](=O)[O-]&#39;,
  &#39;C=C(C)Cc1ncnc(N(C(=O)O)c2cncc3cc(-c4ccc(C)c([N+](=O)[O-])c4)cnc23)c1N&#39;,
  True,
  3.0],
 [&#39;CCSCC[1*:3].Cc1ccc(N(C(=O)[2*:4])[2*:3])c([2*:2])c1.Clc1ncccc1N[2*:1]&#39;,
  &#39;CCSCCN(C(=O)C(=O)O)c1ccc(C)cc1-c1cncc2cc(Nc3cccnc3Cl)cnc12&#39;,
  True,
  1.0],
 [&#39;C#CCO[1*:3].O=c1n([2*:3])nc([2*:2])n1[2*:4].O=c1ccccn1C[2*:1]&#39;,
  &#39;C#CCOn1nc(-c2cncc3cc(Cn4ccccc4=O)cnc23)n(C(=O)O)c1=O&#39;,
  True,
  4.0]]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">block_template</span><span class="o">.</span><span class="n">log</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[[&#39;CC(C)(C)SC[1*:3].Cc1cc([2*:3])c([2*:2])n1C[2*:4].Cc1noc(C)c1CO[2*:1]&#39;,
  &#39;Cc1noc(C)c1COc1cnc2c(-c3c(CSC(C)(C)C)cc(C)n3CC(=O)O)cncc2c1&#39;,
  True,
  3.0],
 [&#39;C=C(C)C[1*:3].Nc1c(N([2*:2])[2*:4])ncnc1[2*:3].Cc1ccc([2*:1])cc1[N+](=O)[O-]&#39;,
  &#39;C=C(C)Cc1ncnc(N(C(=O)O)c2cncc3cc(-c4ccc(C)c([N+](=O)[O-])c4)cnc23)c1N&#39;,
  True,
  3.0],
 [&#39;CCSCC[1*:3].Cc1ccc(N(C(=O)[2*:4])[2*:3])c([2*:2])c1.Clc1ncccc1N[2*:1]&#39;,
  &#39;CCSCCN(C(=O)C(=O)O)c1ccc(C)cc1-c1cncc2cc(Nc3cccnc3Cl)cnc12&#39;,
  True,
  1.0],
 [&#39;C#CCO[1*:3].O=c1n([2*:3])nc([2*:2])n1[2*:4].O=c1ccccn1C[2*:1]&#39;,
  &#39;C#CCOn1nc(-c2cncc3cc(Cn4ccccc4=O)cnc23)n(C(=O)O)c1=O&#39;,
  True,
  4.0]]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

