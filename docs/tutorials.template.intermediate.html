---

title: Tutorial - Templates (Intermediate)


keywords: fastai
sidebar: home_sidebar

summary: "Intermediate overview of using templates"
description: "Intermediate overview of using templates"
nb_path: "nbs/tutorials/tutorials.template.intermediate.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/tutorials/tutorials.template.intermediate.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This tutorial follows from the <a href="/mrl/tutorials.template.beginner.html">Basic Template Tutorial</a>. This tutorial looks more under the hood at filter functions and how they can be extended</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;..&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">mrl.imports</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">mrl.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">mrl.chem</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">mrl.templates.all</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">rdMolDescriptors</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/home/dmai/miniconda3/envs/mrl/lib/python3.6/importlib/_bootstrap.py:219: RuntimeWarning: to-Python converter for boost::shared_ptr&lt;RDKit::FilterCatalogEntry const&gt; already registered; second conversion method ignored.
  return f(*args, **kwds)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>First lets get some compounds</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;files/smiles.csv&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">smiles</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">smiles</span><span class="o">.</span><span class="n">values</span>
<span class="n">mols</span> <span class="o">=</span> <span class="n">to_mols</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>2000</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Previously we looked at building templates from existing filters in the library. Now we'll look at creating custom filters.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Property-Filters">Property Filters<a class="anchor-link" href="#Property-Filters"> </a></h2><p>Property filters calculate some property of a compound and determine if it fallls within a specific range. This is impemented in the <a href="/mrl/template.filters.html#PropertyFilter"><code>PropertyFilter</code></a> class. A <a href="/mrl/template.filters.html#PropertyFilter"><code>PropertyFilter</code></a> takes in a <code>mol_function</code>, which is any function that converts an RDKit <code>Mol</code> to a numeric value.</p>
<p>For example, say we wanted to create a filter for the number of amide bonds in a molecule. We first need to define a function that computes our desired property - in this case the number of amide bonds - and choose a range</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">my_property_function</span><span class="p">(</span><span class="n">mol</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">rdMolDescriptors</span><span class="o">.</span><span class="n">CalcNumAmideBonds</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

<span class="n">my_filter</span> <span class="o">=</span> <span class="n">PropertyFilter</span><span class="p">(</span><span class="n">my_property_function</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;amide bonds&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">my_filter</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>amide bonds (None, 2)</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we have a filter that will return <code>True</code> if a molecule has 2 or fewer amide bonds.</p>
<p>One important point to note is creating <code>my_property_function</code> as a wrapper around the <code>rdMolDescriptors.CalcNumAmideBonds</code>. Why don't we just pass <code>rdMolDescriptors.CalcNumAmideBonds</code> like <code>my_filter = PropertyFilter(rdMolDescriptors.CalcNumAmideBonds, ...)</code></p>
<p>Filters and templates automatically use parallel processing to evauate large numbers of molecules. RDKit functions break python's multiprocessing because RDKit functions can't be pickled. Creating a wrapper around RDKit functions fixes this issue.</p>
<p>Now we can filter compounds based on the 2 or fewer amide bond criteria.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">outputs</span> <span class="o">=</span> <span class="n">my_filter</span><span class="p">(</span><span class="n">mols</span><span class="p">)</span>
<span class="n">passes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">fails</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mols</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">passes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fails</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
        
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">passes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">fails</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>1894 106
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Property-and-Criteria-Functions">Property and Criteria Functions<a class="anchor-link" href="#Property-and-Criteria-Functions"> </a></h2><p>Under the hood, the filter function performs two steps. The first is to compute <a href="/mrl/template.filters.html#PropertyFilter.property_function"><code>PropertyFilter.property_function</code></a>, which for this filter computes the value of <code>my_property_function</code>, the number of amide bonds. The result of the property function is then sent to <a href="/mrl/template.filters.html#PropertyFilter.criteria_function"><code>PropertyFilter.criteria_function</code></a>, which converts the output of the property function to a boolean value based on the <code>min_val</code>, <code>max_val</code> arguments we passed.</p>
<p>Under the hood, it looks like this:</p>

<pre><code>class PropertyFilter(Filter):
    def __init__(self, mol_function, min_val=None, max_val=None, score=None, fail_score=0., name=None):

        self.mol_function = mol_function
        self.min_val = min_val
        self.max_val = max_val

        if name is None:
            name = mol_function.__name__

        super().__init__(score, name, fail_score=fail_score)

    def property_function(self, mol):
        return self.mol_function(mol)

    def criteria_function(self, property_output):
        lower_bound = (property_output&gt;=self.min_val) if self.min_val is not None else True
        upper_bound = (property_output&lt;=self.max_val) if self.max_val is not None else True
        output = lower_bound and upper_bound

        return output</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Custom-Filters">Custom Filters<a class="anchor-link" href="#Custom-Filters"> </a></h2><p>To make custom filters, subclass the main <a href="/mrl/template.filters.html#Filter"><code>Filter</code></a> function and define your own <code>property_function</code> and <code>criteria_function</code>. For a simple example, look at the <a href="/mrl/template.filters.html#SingleCompoundFilter"><code>SingleCompoundFilter</code></a> class. This filter determines if a molecule is a single compound. In SMILES strings, different compounds are separated by a period <code>.</code>. To filter based on the single compound criteria, we need to set up our <code>property_function</code> and <code>criteria_function</code> to return <code>True</code> if a period is not found in the SMILES string.</p>

<pre><code>class SingleCompoundFilter(Filter):
    def __init__(self, score=None, name=None, fail_score=0.):        
        if name is None:
            name = 'Single Compound Filter'

        super().__init__(score, name, fail_score=fail_score)
        self.priority=1

    def property_function(self, mol):
        smile = to_smile(mol)
        return smile

    def criteria_function(self, property_output):
        return not '.' in property_output</code></pre>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Score-Criteria">Score Criteria<a class="anchor-link" href="#Score-Criteria"> </a></h2><p>The above code uses the filter we created as a hard filter that returns True/False pass/fail outputs. By adding a score, we can convert the filter to a soft filter that returns a float value</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">my_filter</span> <span class="o">=</span> <span class="n">PropertyFilter</span><span class="p">(</span><span class="n">my_property_function</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;amide bonds&#39;</span><span class="p">,</span>
                          <span class="n">score</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fail_score</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Passing some mols to the filter with <code>with_score=True</code> will return the soft score rather than the hard boolean values</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">my_filter</span><span class="p">(</span><span class="n">mols</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">with_score</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now the filter returns <code>1</code> for passing molecules and <code>0</code> for failing molecules. For most MPO functions, this will be sufficient. However, we can use fancier score methods if we want to</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Score-Functions">Score Functions<a class="anchor-link" href="#Score-Functions"> </a></h2><p>Under the hood, scores are determined by the <a href="/mrl/template.filters.html#ScoreFunction"><code>ScoreFunction</code></a> class. A score function has a <code>__call__</code> method that takes in the output of a filter's <code>property_function</code> and <code>criteria_function</code> and returns a numeric value.</p>
<p>Lets say for the amide bond example we want our score to actually return <code>1/(1+n)</code> where <code>n</code> is the number of amide bonds. We can implement that as follows:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">MyScore</span><span class="p">(</span><span class="n">ScoreFunction</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">property_output</span><span class="p">,</span> <span class="n">criteria_output</span><span class="p">):</span>
        
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">property_output</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can pass an instance of <code>MyScore</code> to the <code>score</code> keyword argument in <a href="/mrl/template.filters.html#PropertyFilter"><code>PropertyFilter</code></a>. The Filter will verify the passes score function is an instance of the main <a href="/mrl/template.filters.html#ScoreFunction"><code>ScoreFunction</code></a> class, so it's important to subclass</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">score</span> <span class="o">=</span> <span class="n">MyScore</span><span class="p">()</span>
<span class="n">my_filter</span> <span class="o">=</span> <span class="n">PropertyFilter</span><span class="p">(</span><span class="n">my_property_function</span><span class="p">,</span> <span class="n">min_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_val</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;amide bonds&#39;</span><span class="p">,</span>
                          <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can get pass some mols to our filter and see the score defined by our custom score function</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">my_filter</span><span class="p">(</span><span class="n">mols</span><span class="p">[:</span><span class="mi">10</span><span class="p">],</span> <span class="n">with_score</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[0.5,
 0.5,
 0.3333333333333333,
 1.0,
 1.0,
 1.0,
 0.5,
 0.3333333333333333,
 0.5,
 0.5]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>If your property or score calculation is complex, it can be easier to abstract the property calculation and score computation entirely. This can be done with the <a href="/mrl/template.filters.html#PassThroughScore"><code>PassThroughScore</code></a> class, which just returns the output of the property function.</p>

<pre><code>class PassThroughScore(ScoreFunction):
    "Pass through for no score"
    def __call__(self, property_output, criteria_output):
        return property_output</code></pre>
<p>We can set up a filter using this like so</p>

<pre><code>my_filter = PropertyFilter(my_property_function, min_val=None, max_val=None, name='my filter',
                          score=PassThroughScore())</code></pre>
<p>The above filter when used as a soft filter will simply return the output of <code>my_property_function</code>. When used as a hard filter will always return <code>True</code> since <code>min_val</code> and <code>max_val</code> are <code>None</code>.</p>

</div>
</div>
</div>
</div>
 

