# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_templates.ipynb (unless otherwise specified).

__all__ = ['PropertyFunction', 'MolProperty', 'RangeProperty', 'SmartsMatch', 'ExclusionMatch', 'FingerprintSimilarity',
           'ScoreFunction', 'NoScore', 'ConstantScore', 'LinearDecayScore', 'FilterFunction', 'PropertyFilter',
           'MolWtFilter', 'HBDFilter', 'HBAFilter', 'TPSAPFilter', 'RotBondFilter', 'SP3Filter', 'LogPFilter',
           'RingFilter', 'HeteroatomFilter', 'AromaticRingFilter', 'StructureFilter', 'FPFilter']

# Cell
# hide
from .imports import *
from .core import *
from .chem import *

# Cell

class PropertyFunction():
    '''
    PropertyFunction - base class for property functions.

    When subclassing, define the `calc_property` and `criteria` functions
    '''
    def __call__(self, mol):
        prop = self.calc_property(mol)
        prop_bool = self.criteria(prop)
        return prop_bool

    def calc_property(self, mol):
        pass

    def criteria(self, prop):
        pass


class MolProperty(PropertyFunction):
    '''
    MolProperty - base property class for all properties that can be computed as `mol_function(mol)`

    ex: prop_func = MolProperty(molwt)

    note that the `criteria` function is not defined here
    '''
    def __init__(self, mol_function):
        self.mol_function = mol_function

    def calc_property(self, mol):
        mol = to_mol(mol)
        return self.mol_function(mol)


class RangeProperty(MolProperty):
    '''
    RangeProperty - class for calculating properties and evaluating them within a defined range

    Inputs:
        `mol_function` - any function that takes as input a `Mol` and returns a numeric value
        `min_val` - float, None, minimum value. Ignored if None
        `max_val` - float, None, maximum value. Ignored if None

    If `min_val` and `max_val` are both None, `criteria` will always return True

    prop_func = RangeProperty(molwt, 100, 300)
    prop_func(to_mol('O=C(C)Oc1ccccc1C(=O)O'))
    >> True
    '''
    def __init__(self, mol_function, min_val=None, max_val=None):
        super().__init__(mol_function)
        self.min_val = min_val
        self.max_val = max_val

    def criteria(self, prop):
        lower_bound = (prop>=self.min_val) if self.min_val is not None else True
        upper_bound = (prop<=self.max_val) if self.max_val is not None else True
        output = lower_bound and upper_bound

        return output


# Cell

class SmartsMatch(PropertyFunction):
    '''
    SmartsMatch - class for substructure matching a `Mol` against a `Catalog`

    Inputs:
        `catalog` - a subclass of `Catalog`
        `crit` - str ('any', 'all'). If any, will return True if any structure in `catalog` matches the `Mol`.

    catalog = PAINSACatalog()
    prop_func = SmartsMatch(catalog, crit='any')
    prop_func(to_mol('O=C(Cn1cnc2c1c(=O)n(C)c(=O)n2C)N/N=C/c1c(O)ccc2c1cccc2'))
    >> True

    prop_func = SmartsMatch(catalog, crit='all')
    prop_func(to_mol('O=C(Cn1cnc2c1c(=O)n(C)c(=O)n2C)N/N=C/c1c(O)ccc2c1cccc2'))
    >> False
    '''
    def __init__(self, catalog, crit='any'):
        self.catalog = catalog
        assert isinstance(self.catalog, Catalog), "`catalog_match` must be a subclass of `Catalog`"
        assert crit in ('any', 'all'), "`crit` must be one of ('any', 'all')"
        self.crit = crit

    def calc_property(self, mol):
        return self.catalog(mol, criteria=self.crit)

    def criteria(self, prop):
        if not type(prop) == list:
            prop = [prop]

        if self.crit=='any':
            output = any(prop)
        else:
            output = all(prop)

        return output

    @classmethod
    def from_smarts(cls, smarts, crit='any'):
        "Returns a `SmartsMatch` object with a `SmartsCatalog` from the given `smarts`"
        catalog = SmartsCatalog(smarts)
        return cls(catalog, crit)


# Cell

class ExclusionMatch(SmartsMatch):
    '''
    ExclusionMatch - class for exclusion matching a `Mol` against a `Catalog`.
    Returns `False` when `Mol` matches one of the filters in `Catalog`

    Inputs:
        `catalog` - a subclass of `Catalog`
        `crit` - str ('any', 'all'). If any, will return True if any structure in `catalog` matches the `Mol`.
    '''
    def criteria(sef, prop):
        return not super().criteria(prop)

# Cell

class FingerprintSimilarity(PropertyFunction):
    def __init__(self, reference_fps, fp_type, fp_metric, crit='any', fp_thresh=0.):
        self.reference_fps = reference_fps
        self.fp = FP()
        self.fp_type = fp_type
        self.fp_metric = fp_metric
        self.array_type = self.fp._np_or_rd(reference_fps)
        self.get_fp = partial(self.fp.get_fingerprint, fp_type=self.fp_type, output_type=self.array_type)
        self.get_similaity = partial(self.fp.fingerprint_similaity,
                                     fps2=self.reference_fps, metric=fp_metric)
        self.crit = crit
        self.fp_thresh = fp_thresh

    def calc_property(self, mol):
        fp = self.get_fp(mol)
        similarity = self.get_similaity(fp)
        return similarity

    def criteria(self, prop):
        bools = prop>=self.fp_thresh

        if self.crit=='any':
            output = any(bools)
        else:
            output = all(bools)

        return output

    @classmethod
    def from_smiles(cls, reference_smiles, fp_type='ECFP6', fp_metric='tanimoto', crit='any', fp_thresh=0.):
        # `reference_smiles` can be a list of smiles or a list of `Mols`
        reference_fps = get_fingerprint(reference_smiles, fp_type=fp_type)
        return cls(reference_fps, fp_type, fp_metric, crit=crit, fp_thresh=fp_thresh)


# Cell

class ScoreFunction():
    "Base score function"
    def __call__(self, property_output, criteria_output):
        pass

class NoScore(ScoreFunction):
    "Pass through for no score"
    def __call__(self, property_output, criteria_output):
        return 0.

class ConstantScore(ScoreFunction):
    '''
    ConstantScore - returns `pass_score` if `criteria_output=True`, else `fail_score
    '''
    def __init__(self, pass_score, fail_score=0.):
        self.pass_score = pass_score
        self.fail_score = fail_score

    def __call__(self, property_output, criteria_output):
        if criteria_output:
            output = self.pass_score
        else:
            output = self.fail_score

        return output

class LinearDecayScore(ConstantScore):
    '''
    LinearDecayScore - score with linear decay. `low_start<low_end<high_start<high_end`

    Returns `pass_score` if `criteria_output=True` and
    `low_end<=property_output<=high_start`. If `low_start<=property_output<=low_end` or
    `high_start<=property_output<=high_end`, the score is a linear interpolation between `pass_score`
    and `fail_score`. Otherwise, returns `fail_score`.

    One of `low_end`, `high_start` must be not None.

    If one of `low_end`, `high_start` is None, the corresponding bound is ignored

    if `low_start` or `high_end` is None, the score immediately drops to `fail_score`

    '''
    # low_start < low_end < high_start < high_end
    def __init__(self, pass_score, low_start, low_end,
                 high_start, high_end, fail_score=0.):
        super().__init__(pass_score, fail_score)

        self.low_start = low_start
        self.high_start = high_start

        self.low_end = low_end
        self.high_end = high_end

        assert (self.low_end is not None) or (self.high_start is not None), ("One of (low_end, high_start) "
                                                                             "must not be None")

    def check_bound(self, property_output, bound, boundtype):
        if bound is None:
            output = True
        else:
            if boundtype=='low':
                output = property_output>=bound
            else:
                output = property_output<=bound

        return output

    def __call__(self, property_output, criteria_output):

        if criteria_output:

            low_bound = self.check_bound(property_output, self.low_end, 'low')
            high_bound = self.check_bound(property_output, self.high_start, 'high')

            if low_bound and high_bound:
                # in main range
                output = self.pass_score

            elif low_bound:
                # above high start:
                high_end = self.check_bound(property_output, self.high_end, 'high')

                if high_end:
                    # between high_start and high_end
                    if (self.high_start is not None) and (self.high_end is not None):
                        fraction = (property_output - self.high_start)/(self.high_end - self.high_start)
                        output = self.pass_score*(1-fraction) + self.fail_score*fraction
                    else:
                        output = self.fail_score

                else:
                    output = self.fail_score

            else:
                # below low end
                low_start = self.check_bound(property_output, self.low_start, 'low')

                if low_start:
                    # between low_start and low_end
                    if (self.low_start is not None) and (self.low_end is not None):
                        fraction = (property_output - self.low_start)/(self.low_end - self.low_start)
                        output = self.pass_score*fraction + self.fail_score*(1-fraction)
                    else:
                        output = self.fail_score

                else:
                    output = self.fail_score

        else:
            output = self.fail_score

        return output


# Cell

class FilterFunction():
    '''
    FilterFunction - base filter function class

    Inputs:
        `property_function` - subclass of `PropertyFunction`
        `score_function` - one of (None, int, float, ScoreFunction), see `set_score`
        `name` - (str, None), filter name used for repr
        `fail_score` - (float, int), used in `set_score` if `score_function` is (int, float)
    '''
    def __init__(self, property_function, score_function, name=None, fail_score=0.):
        self.property_function = property_function
        assert isinstance(self.property_function, PropertyFunction), ("`property_function` must "
                                                                      "subclass PropertyFunction")
        self.score_function = self.set_score(score_function, fail_score)
        self.name = name

    def set_score(self, score_function, fail_score):
        if score_function is None:
            score = NoScore()
        elif type(score_function) in (int, float):
            score = ConstantScore(score_function, fail_score=fail_score)
        elif isinstance(score, ScoreFunction):
            score = score
        else:
            raise ValueError('Invalid score_function input, must be one of (None, int, float, ScoreFunction)')

        return score

    def __call__(self, mol, with_score=True):
        output = maybe_parallel(self.eval_mol, mol, with_score=with_score)
        return output

    def eval_mol(self, mol, with_score=True):
        '''
        eval_mol - evaluates `Mol` based on `property_function`.
            if `with_score=True`, returns the output of `score_function`, else
            returns the output of `property_function
        '''
        mol = to_mol(mol)
        property_output = self.property_function.calc_property(mol)
        criteria_output = self.property_function.criteria(property_output)

        if with_score:
            output = self.score_function(property_output, criteria_output)
        else:
            output = criteria_output

        return output

    def __repr__(self):
        if self.name is not None:
            output = f'{self.name}'
        else:
            output = 'Filter'

        return output

# Cell
class PropertyFilter(FilterFunction):
    '''
    PropertyFilter - filters mols based on `mol_function`

    Inputs:
        `mol_function` - any function that takes as input a `Mol` object and returns a single numeric value
        `min_val` - (None, int, float), lower bound for filter (ignored if None)
        `max_val` - (None, int, float), upper bound for filter (ignored if None)
        `score` - one of (None, int, float, ScoreFunction), see `FilterFunction.set_score`
        `name` - (str, None), filter name used for repr
        `fail_score` - (float, int), used in `set_score` if `score_function` is (int, float)
    '''
    def __init__(self, mol_function, min_val, max_val, score, fail_score=0., name=None):
        property_function = RangeProperty(mol_function, min_val, max_val)

        if name is None:
            name = mol_function.__name__ + f' ({min_val}, {max_val})'

        super().__init__(property_function, score, name, fail_score=fail_score)


class MolWtFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(molwt, min_val, max_val, score, name)

class HBDFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(hbd, min_val, max_val, score, name)

class HBAFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(hba, min_val, max_val, score, name)

class TPSAPFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(tpsa, min_val, max_val, score, name)

class RotBondFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(rotbond, min_val, max_val, score, name)

class SP3Filter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(fsp3, min_val, max_val, score, name)

class LogPFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(logp, min_val, max_val, score, name)

class RingFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(rings, min_val, max_val, score, name)

class HeteroatomFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(heteroatoms, min_val, max_val, score, name)

class AromaticRingFilter(PropertyFilter):
    def __init__(self, min_val, max_val, score=None, name=None):
        super().__init__(aromaticrings, min_val, max_val, score, name)


# Cell

class StructureFilter(FilterFunction):
    '''
    StructureFilter - filters mols based on structures in `smarts`

    Inputs:
        `smarts` - (list, SmartsCatalog), list of smarts strings for filtering or `SmartsCatalog`
        `score` - one of (None, int, float, ScoreFunction), see `FilterFunction.set_score`
        `exclude` - if True, filter returns `False` when a structure match is found
        `criteria` - ('any', 'all'), match criteria (match any filter, match all filters)
        `name` - (str, None), filter name used for repr
        `fail_score` - (float, int), used in `set_score` if `score_function` is (int, float)
    '''
    def __init__(self, smarts, score, exclude=True, criteria='any', name=None, fail_score=0.):
        catalog = self.get_catalog(smarts)
        if exclude:
            property_function = ExclusionMatch(catalog, crit=criteria)
        else:
            property_function = SmartsMatch(catalog, crit=criteria)

        if name is None:
            name = f'Structure filter, criteria: {criteria}, exclude: {exclude}'

        super().__init__(property_function, score, name, fail_score=fail_score)

    def get_catalog(self, smarts):
        if isinstance(smarts, Catalog):
            smarts = smarts
        else:
            smarts = SmartsCatalog(smarts)
        return smarts

class FPFilter(FilterFunction):
    '''
    FPFilter - filters mols based on fingerprint similarity to `reference_smiles`

    Inputs:
        `reference_smiles` - (list), list of smiles or `Mol` objects for comparison
        `score` - one of (None, int, float, ScoreFunction), see `FilterFunction.set_score`
        `fp_type` - fingerprint function. see `FP`
        `fp_metric` - fingerprint similarity metric. see `FP`
        `criteria` - ('any', 'all'), match criteria (match any reference, match all references)
        `fp_thresh` - float, fingerprint similarity cutoff for defining a match
        `name` - (str, None), filter name used for repr
        `fail_score` - (float, int), used in `set_score` if `score_function` is (int, float)
    '''
    def __init__(self, reference_smiles, score, fp_type, fp_metric, criteria='any',
                fp_thresh=0., name=None, fail_score=0.):
        property_function = FingerprintSimilarity.from_smiles(reference_smiles, fp_type, fp_metric,
                                                             criteria, fp_thresh)

        if name is None:
            name = f'Fingerprint Filter, {fp_type}, {fp_metric}, {len(reference_smiles)} references'

        super().__init__(property_function, score, name, fail_score=fail_score)