# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/10_generative_models.lstm_lm.ipynb (unless otherwise specified).

__all__ = ['LSTM_LM', 'Conditional_LSTM_LM']

# Cell

from ..imports import *
from ..torch_imports import *
from ..torch_core import *
from ..layers import *
from .generative_base import *

# Cell

class LSTM_LM(GenerativeModel):
    def __init__(self, d_vocab, d_embedding, d_hidden, n_layers,
                input_dropout=0., lstm_dropout=0., bos_idx=0,
                bidir=False, tie_weights=False):
        super().__init__()

        self.embedding = nn.Embedding(d_vocab, d_embedding)

        self.lstm = LSTM(d_embedding, d_hidden, d_embedding, n_layers,
                                     bidir=bidir, input_dropout=input_dropout,
                                     lstm_dropout=lstm_dropout)

        self.head = nn.Linear(d_embedding, d_vocab)

        if tie_weights:
            self.embedding.weight = self.head.weight

        self.bos_idx = bos_idx

    def _forward(self, x, hiddens=None):
        x = self.embedding(x)
        encoded, hiddens = self.lstm(x, hiddens)
        output = self.head(encoded)
        return output, hiddens, encoded

    def forward(self, x, hiddens=None):
        output, hiddens, encoded = self._forward(x, hiddens)

        return output

    def x_to_latent(self, x):
        return None

    def sample(self, bs, sl, z=None, temperature=1., multinomial=True):

        current_device = next(self.parameters()).device

        start_idx = torch.tensor([self.bos_idx]*bs).long().unsqueeze(-1)

        preds = idxs = to_device(start_idx, device=current_device)
        lps = []

        hiddens = None

        for i in range(sl):
            x, hiddens, encoded = self._forward(idxs, hiddens)
            x.div_(temperature)

            idxs, lp = x_to_preds(x, multinomial=multinomial)

            lps.append(lp)
            preds = torch.cat([preds, idxs], -1)

        return preds[:, 1:], torch.cat(lps,-1)

    def sample_no_grad(self, bs, sl, z=None, temperature=1., multinomial=True):
        with torch.no_grad():
            return self.sample(bs, sl, temperature=temperature, multinomial=multinomial)

    def get_rl_tensors(self, x, y, temperature=1., latent=None):
        output, hiddens, encoded = self._forward(x)
        output.div_(temperature)
        lps = F.log_softmax(output, -1)
        lps_gathered = gather_lps(lps, y)
        return output, lps, lps_gathered, encoded

# Cell

class Conditional_LSTM_LM(GenerativeModel):
    def __init__(self, encoder, d_vocab, d_embedding, d_hidden, d_latent, n_layers,
                 input_dropout=0., lstm_dropout=0., norm_latent=True,
                 condition_hidden=True, condition_output=False, bos_idx=0, prior=None):
        super().__init__()

        self.encoder = encoder

        self.decoder = Conditional_LSTM_Block(d_vocab, d_embedding, d_hidden, d_embedding,
                                d_latent, n_layers, input_dropout=input_dropout,
                                lstm_dropout=lstm_dropout,
                                condition_hidden=condition_hidden, condition_output=condition_output)

        self.norm_latent = norm_latent
        self.bos_idx = bos_idx

        if prior is None:
            prior = SphericalPrior(torch.zeros((encoder.d_latent)), torch.zeros((encoder.d_latent)),
                                trainable=False)

        self.prior = prior

    def forward(self, x, condition, hiddens=None):
        z = self.encoder(condition)

        z = self.maybe_norm(z)

        x, hiddens, encoded = self.decoder(x, z, hiddens)
        return x

    def maybe_norm(self, z):
        if self.norm_latent:
            z = F.normalize(z, p=2, dim=-1)

        return z

    def x_to_latent(self, x):

        x, condition = x
        z = self.encoder(condition)
        z = self.maybe_norm(z)

        return z

    def sample(self, bs, sl, z=None, temperature=1., multinomial=True):

        current_device = next(self.parameters()).device

        if z is None:
            if self.prior is not None:
                z = to_device(self.prior.rsample([bs]), device=current_device)
            else:
                z = to_device(torch.randn((bs, self.encoder.d_latent)), device=current_device)
        else:
            bs = z.shape[0]

        z = self.maybe_norm(z)

        start_idx = torch.tensor([self.bos_idx]*bs).long().unsqueeze(-1)

        preds = idxs = to_device(start_idx, device=current_device)

        lps = []

        hiddens = None

        for i in range(sl):

            x, hiddens, encoded = self.decoder(idxs,z,hiddens)
            x.div_(temperature)

            idxs, lp = x_to_preds(x, multinomial=multinomial)

            lps.append(lp)
            preds = torch.cat([preds, idxs], -1)

        return preds[:, 1:], torch.cat(lps,-1)

    def sample_no_grad(self, bs, sl, z=None, temperature=1., multinomial=True):
        with torch.no_grad():
            return self.sample(bs, sl, z=z, temperature=temperature, multinomial=multinomial)

    def get_rl_tensors(self, x, y, temperature=1., latent=None):
        x,c = x
        if latent is None:
            latent = self.encoder(c)

        latent = self.maybe_norm(latent)

        output, hiddens, encoded = self.decoder(x,latent)
        output.div_(temperature)
        lps = F.log_softmax(output, -1)

        if self.prior.trainable:
            prior_lps = self.prior.log_prob(latent)
            prior_lps = prior_lps.mean(-1).unsqueeze(-1).unsqueeze(-1)
            pass_through = torch.zeros(prior_lps.shape).float().to(prior_lps.device)
            pass_through = pass_through + prior_lps - prior_lps.detach() # add to gradient chain
            lps = lps + pass_through

        lps_gathered = gather_lps(lps, y)
        return output, lps, lps_gathered, encoded

    def set_prior_from_latent(self, z, logvar, trainable=False):
        z = z.detach()
        logvar = logvar.detach()
        self.prior = SphericalPrior(z, logvar, trainable)

    def set_prior_from_encoder(self, condition, logvar, trainable=False):
        assert condition.shape[0]==1
        z = self.encoder(condition)
        z = self.maybe_norm(z)
        z = z.squeeze(0)
        self.set_prior_from_latent(z, logvar, trainable)