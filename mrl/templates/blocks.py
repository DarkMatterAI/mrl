# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_template.blocks.ipynb (unless otherwise specified).

__all__ = ['Block', 'MolBlock', 'ConstantBlock', 'ConstantMolBlock', 'BlockTree', 'MolBlockTree']

# Cell
from ..imports import *
from ..core import *
from ..chem import *
from .filters import *
from .template import *

# Cell

class Block():
    def __init__(self, template, links, name, subblocks=[]):
        self.template = template
        self.links = links
        self.name = name
        self.subblocks = subblocks
        self.sublinks = []
        self.update_links()

    def update_links(self):
        for b in self.subblocks:
            self.sublinks.append(b.links)
            for sl in b.sublinks:
                self.sublinks.append(sl)

    def eval_mol(self, mol):
        mol = to_mol(mol)
        smile = to_smile(mol)

        if self.match_fragment(smile):
            hardpass, hardlog = self.template.hf(mol)
        else:
            hardpass = False
            hardlog = []

        if hardpass:
            score, softlog = self.template.sf(mol)
        else:
            score = self.template.fail_score
            softlog = []

        return [hardpass, score, hardlog, softlog]

    def match_fragment(self, fragment):
        # determine if fragment matches block link pattern
        raise NotImplementedError

    def match_fragment_recursive(self, fragment):
        # recursively match fragment to all subblocks
        if self.match_fragment(fragment):
            output = True
        else:
            output = False
            for block in self.subblocks:
                if block.match_fragment_recursive(fragment):
                    output = True

        return output

    def sample(self, n, log='hard'):
        return self.template.sample(n, log=log)

    def load_data(self, fragments, recurse=False):
        # checks fragment attachments, then sends to template `load_data`
        # optionally recursive
        if recurse:
            for b in self.subblocks:
                b.load_data(fragments, recurse=True)

        matches = maybe_parallel(self.match_fragment, fragments)
        fragments = [fragments[i] for i in range(len(fragments)) if matches[i]]
        self.template.screen_mols(fragments)

    def decompose_fragments(self, fragment_string):
        # decomposes a string of multiple fragments into a list of single fragments
        raise NotImplementedError

    def join_fragments(self, fragment_list):
        # joins list of fragments into single string
        raise NotImplementedError

    def fuse_fragments(self, fragment_string):
        # fuses fragment string into single output
        raise NotImplementedError

    def join_and_fuse(self, fragment_list):
        return self.fuse_fragments(self.join_fragments(fragment_list))

    def recurse_fragments(self, fragment, add_constant=True):
        # recursively break down fragments, route to subblocks, fuse and evaluate
        raise NotImplementedError

    def __repr__(self):

        rep_str = f'Block {self.name}: {self.links}\n\t' + '\n\t'.join(self.template.__repr__().split('\n'))

        if self.subblocks:
            rep_str += '\n'
            for b in self.subblocks:
                rep_str += '\n\t' + '\n\t'.join(b.__repr__().split('\n'))

        return rep_str


# Cell

class MolBlock(Block):
    def __init__(self, template, links, name, subblocks=[]):
        super().__init__(template, links, name, subblocks=subblocks)

        # self.links = ['1*:2', '1*:3']
        self.pattern = re.compile('\[.\*:.]')

        for link in self.links:
            assert not '0*' in link, "Do not use 0 as an isotope, RDKit automatically removes it"

    def pattern_match(self, fragment):
        matches = self.pattern.findall(fragment)
        return [i[1:-1] for i in matches]

    def is_mapped(self, fragment):
        if fragment.count('*') == len(self.pattern_match(fragment)):
            mapped = True
        else:
            mapped = False

        return mapped

    def add_mapping(self, fragment, links=None):
        if self.is_mapped(fragment):
            # already mapped
            mapped = fragment
        else:
            if len(self.pattern_match(fragment))>0:
                # partially mapped, something went wrong
                fragment = self.remove_mapping(fragment)

            if links is None:
                links = list(self.links)
                random.shuffle(links)

            mapped = ''
            link_count = 0
            for s in fragment:
                if s=='*':
                    s = f'[{links[link_count]}]'
                    link_count += 1
                mapped += s

        return mapped

    def remove_mapping(self, fragment):
        matches = self.pattern_match(fragment)
        for match in matches:
            fragment = fragment.replace(f'[{match}]', '*')
        return fragment

    def match_fragment(self, fragment):

        match = False
        if fragment.count('*') == len(self.links):
            if not self.is_mapped(fragment):
                fragment = self.add_mapping(fragment)

            matches = self.pattern_match(fragment)
            if len(matches)==len(set(matches)) and set(matches)==set(self.links):
                match = True

        return match

    def load_fragment(self, fragment):
        if fragment.count('*') == len(self.links):
            fragment = self.add_mapping(fragment)
            fragpass = True
        else:
            fragpass = False

        return [fragment, fragpass]

    def load_data(self, fragments, recurse=False):
        if recurse:
            for b in self.subblocks:
                b.load_data(fragments, recurse=True)

        fragments = maybe_parallel(self.load_fragment, fragments)
        fragments = [i[0] for i in fragments if i[1]]
        self.template.screen_mols(fragments)

    def sample_smiles(self, n, log='hard'):
        return self.template.sample_smiles(n, log=log)

    def shuffle_mapping(self, fragment):
        current_mapping = self.pattern_match(fragment)
        new_mapping = list(current_mapping)
        random.shuffle(new_mapping)

        fragment = self.remove_mapping(fragment)
        fragment = self.add_mapping(fragment, links=new_mapping)
        return fragment

    def decompose_fragments(self, fragment_string):
        return fragment_string.split('.')

    def join_fragments(self, fragment_list):
        return '.'.join(fragment_list)

    def fuse_fragments(self, fragment_string):
        new_smile = fuse_on_atom_mapping(fragment_string)
        return new_smile

    def recurse_fragments(self, fragments, add_constant=True):

        output_dicts = []
        total_pass = []
        total_score = 0.

        if type(fragments) == str:
            fragments = [fragments]

        fragments = [self.decompose_fragments(i) for i in fragments]
        fragments = [item for sublist in fragments for item in sublist]

        if self.subblocks:
            new_fragments = []

            unrouted = list(fragments) # copy list

            for sb in self.subblocks:
                routed = [i for i in unrouted if sb.match_fragment_recursive(i)]
                unrouted = [i for i in unrouted if not i in routed]

                if routed:
                    r_fused, r_pass, r_score, subdicts = sb.recurse_fragments(routed)
                    new_fragments.append(r_fused)
                    total_pass.append(r_pass)
                    total_score += r_score
                    output_dicts += subdicts

                if isinstance(sb, ConstantBlock) and add_constant:
                    new_fragments.append(sb.smile)

            fragments = new_fragments + unrouted

        joined_fragments = self.join_fragments(fragments)
        fused = self.fuse_fragments(joined_fragments)

        frag_pass, frag_score, hardlog, softlog = self.eval_mol(fused)
        total_pass.append(frag_pass)
        total_score += frag_score

        total_pass = all(total_pass)

        output_dict = {
            'block' : self.name,
            'fused' : fused,
            'fragments' : fragments,
            'block_pass' : frag_pass,
            'block_score' : frag_score,
            'all_pass' : total_pass,
            'all_score' : total_score,
            'hardlog' : hardlog,
            'softlog' : softlog
        }

        output_dicts.append(output_dict)

        return fused, total_pass, total_score, output_dicts


# Cell

class ConstantBlock():
    def __init__(self, constant, name):
        self.constant = constant
        self.name = name
        self.links = []
        self.subblocks = []
        self.sublinks = []

    def match_fragment(self, fragment):
        return False

    def match_fragment_recursive(self, fragment):
        return False

    def load_data(self, fragments, recurse=False):
        pass

    def sample_data(self, n):
        return pd.DataFrame([self.constant, 0.]*n, columns=['smiles', 'final'])

    def __repr__(self):

        rep_str = f'Constant Block: {self.constant}'

        return rep_str


class ConstantMolBlock(ConstantBlock):
    def __init__(self, smile, name):
        super().__init__(smile, name)
        self.smile = canon_smile(smile)
        if '[*' in self.smile:
            self.smile = self.smile.replace('[*', '[0*')
        self.pattern = re.compile('\[.\*:.]')
        self.links = [i[1:-1] for i in self.pattern.findall(smile)]

    def sample_smiles(self, n):
        return [self.smile]*n

    def __repr__(self):

        rep_str = f'Constant Block: {self.smile}'

        return rep_str


# Cell

class BlockTree():
    def __init__(self, head_block):
        self.head_block = head_block
        self.nodes = self.nodes_to_list(self.head_block)
        self.leaf_nodes = [i for i in self.nodes if not i.subblocks]
        self.live_leafs = [i for i in self.leaf_nodes if not isinstance(i, ConstantBlock)]
        self.node_dict = {i.name:i for i in self.nodes}
        self.log = []

    def nodes_to_list(self, block):
        nodes = [block]
        if block.subblocks:
            for subblock in block.subblocks:
                nodes += self.nodes_to_list(subblock)

        return nodes

    def log_outputs(self, outputs):

        log_dict = {}

        for output_dict in outputs:
            if not output_dict['block'] in log_dict.keys():
                log_dict[output_dict['block']] = {'hard':[],
                                                  'soft':[]}

            if output_dict['hardlog']:
                log_dict[output_dict['block']]['hard'].append(output_dict['hardlog'])

            if output_dict['softlog']:
                log_dict[output_dict['block']]['soft'].append(output_dict['softlog'])

        for blockname in log_dict.keys():
            node = self.node_dict[blockname]
            if not log_dict[blockname]['hard']==[]:
                node.template.log_data(log_dict[blockname]['hard'], filter_type='hard')

            if not log_dict[blockname]['soft']==[]:
                node.template.log_data(log_dict[blockname]['soft'], filter_type='soft')

    def recurse_fragments(self, fragments, add_constant=True):

        if type(fragments) == str:
            fragments = [fragments]

        outputs = maybe_parallel(self.head_block.recurse_fragments, fragments, add_constant=add_constant)
        output_data = []
        output_dicts = []

        for i, out in enumerate(outputs):
            fused, allpass, allscore, log_dicts = out
            output_data.append([fragments[i], fused, allpass, allscore])
            output_dicts += log_dicts

        self.log_outputs(output_dicts)
        self.log += output_data
        return output_data

    def sample_leaf_nodes(self, include_constant=False):
        pass

    def combinatorial_sample(self, n_sample, max_n, include_constant=False):
        pass


class MolBlockTree(BlockTree):
    def __init__(self, head_block):
        super().__init__(head_block)

    def _sample_leaf_nodes(self, include_constant=False):
        if include_constant:
            leaf_nodes = self.leaf_nodes
        else:
            leaf_nodes = self.live_leafs

        output = []

        for node in leaf_nodes:
            output.append(node.sample_data(1))

        output = [list(i.smiles.values) for i in output]

        return output

    def sample_leaf_nodes(self, n, include_constant=False):
        return maybe_parallel(self._sample_leaf_nodes, [include_constant]*n)

    def combinatorial_sample(self, n_sample, max_n, include_constant=False):

        if include_constant:
            leaf_nodes = self.leaf_nodes
        else:
            leaf_nodes = self.live_leafs

        output = []

        for node in leaf_nodes:
            output.append(node.sample_data(n_sample))

        output = [list(set(i.smiles.values)) for i in output]
        it = itertools.product(*output)

        prods = []

        for i, p in enumerate(it):
            prods.append(p)
            if i>max_n:
                break

        return prods