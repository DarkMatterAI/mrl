# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_template.blocks.ipynb (unless otherwise specified).

__all__ = ['ConstantBlock', 'ConstantMolBlock', 'sample_leaf_nodes', 'sample_leaf_nodes_n', 'BlockTree', 'MolBlockTree']

# Cell
from ..imports import *
from ..core import *
from ..chem import *
from .filters import *
from .template import *

# Cell

class ConstantBlock():
    def __init__(self, constant, name):
        self.constant = constant
        self.name = name
        self.links = []
        self.subblocks = []
        self.sublinks = []

    def match_fragment(self, fragment):
        return False

    def match_fragment_recursive(self, fragment):
        return False

    def load_data(self, fragments, recurse=False):
        pass

    def sample_data(self, n):
        return pd.DataFrame([self.constant, 0.]*n, columns=['smiles', 'final'])

    def __repr__(self):

        rep_str = f'Constant Block: {self.constant}'

        return rep_str


class ConstantMolBlock(ConstantBlock):
    def __init__(self, smile, name):
        super().__init__(smile, name)
        self.smile = canon_smile(smile)
        if '[*' in self.smile:
            self.smile = self.smile.replace('[*', '[0*')
        self.pattern = re.compile('\[.\*:.]')
        self.links = [i[1:-1] for i in self.pattern.findall(smile)]

    def sample_smiles(self, n):
        return [self.smile]*n

    def __repr__(self):

        rep_str = f'Constant Block: {self.smile}'

        return rep_str


# Cell

def sample_leaf_nodes(block, include_constant=False):
    if block.subblocks:
        output = [sample_leaf_nodes(i, include_constant=include_constant) for i in block.subblocks]
    else:
        if not isinstance(block, ConstantBlock):
            output = block.sample_smiles(1)
        else:
            if include_constant:
                output = block.sample_smile(1)
            else:
                output = None

    if type(output) == list:
        output = flatten_recursive(output)
        output = [i for i in output if i is not None]

    return output

def sample_leaf_nodes_n(n, block, include_constant=False):
    output = [sample_leaf_nodes(block, include_constant=include_constant) for i in range(n)]
    return output

# Cell

class BlockTree():
    def __init__(self, head_block):
        self.head_block = head_block
        self.nodes = self.nodes_to_list(self.head_block)
        self.leaf_nodes = [i for i in self.nodes if not i.subblocks]
        self.live_leafs = [i for i in self.leaf_nodes if not isinstance(i, ConstantBlock)]
        self.node_dict = {i.name:i for i in self.nodes}
        self.log = []

    def nodes_to_list(self, block):
        nodes = [block]
        if block.subblocks:
            for subblock in block.subblocks:
                nodes += self.nodes_to_list(subblock)

        return nodes

    def log_outputs(self, outputs):

        log_dict = {}

        for output_dict in outputs:
            if not output_dict['block'] in log_dict.keys():
                log_dict[output_dict['block']] = {'hard':[],
                                                  'soft':[]}

            if output_dict['hardlog']:
                log_dict[output_dict['block']]['hard'].append(output_dict['hardlog'])

            if output_dict['softlog']:
                log_dict[output_dict['block']]['soft'].append(output_dict['softlog'])

        for blockname in log_dict.keys():
            node = self.node_dict[blockname]
            if not log_dict[blockname]['hard']==[]:
                node.template.log_data(log_dict[blockname]['hard'], filter_type='hard')

            if not log_dict[blockname]['soft']==[]:
                node.template.log_data(log_dict[blockname]['soft'], filter_type='soft')

    def recurse_fragments(self, fragments, add_constant=True):

        if type(fragments) == str:
            fragments = [fragments]

        outputs = maybe_parallel(self.head_block.recurse_fragments, fragments, add_constant=add_constant)
        output_data = []
        output_dicts = []

        for i, out in enumerate(outputs):
            fused, allpass, allscore, log_dicts = out
            output_data.append([fragments[i], fused, allpass, allscore])
            output_dicts += log_dicts

        self.log_outputs(output_dicts)
        self.log += output_data
        return output_data

    def sample_leaf_nodes(self, include_constant=False):
        pass

    def combinatorial_sample(self, n_sample, max_n, include_constant=False):
        pass


class MolBlockTree(BlockTree):
    def __init__(self, head_block):
        super().__init__(head_block)

    def _sample_leaf_nodes(self, include_constant=False):
        if include_constant:
            leaf_nodes = self.leaf_nodes
        else:
            leaf_nodes = self.live_leafs

        output = []

        for node in leaf_nodes:
            output.append(node.sample_data(1))

        output = [list(i.smiles.values) for i in output]

        return output

    def sample_leaf_nodes(self, n, include_constant=False):
        return maybe_parallel(self._sample_leaf_nodes, [include_constant]*n)

    def combinatorial_sample(self, n_sample, max_n, include_constant=False):

        if include_constant:
            leaf_nodes = self.leaf_nodes
        else:
            leaf_nodes = self.live_leafs

        output = []

        for node in leaf_nodes:
            output.append(node.sample_data(n_sample))

        output = [list(set(i.smiles.values)) for i in output]
        it = itertools.product(*output)

        prods = []

        for i, p in enumerate(it):
            prods.append(p)
            if i>max_n:
                break

        return prods