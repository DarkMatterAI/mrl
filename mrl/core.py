# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['is_container', 'flatten_recursive', 'flatten_list_of_lists', 'deduplicate_list', 'chunk_list',
           'maybe_parallel']

# Cell
from .imports import *

# Cell
def is_container(x):
    "check if `x` is a container (used for parallel processing)"
    if (type(x) == list) or (type(x) == np.ndarray):
        return True
    else:
        return False

def flatten_recursive(list_of_lists):
    "Recursively flattel list of lists"
    flat_list = []
    for item in list_of_lists:
        if type(item) == list:
            flat_list += flatten_recursive(item)
        else:
            flat_list.append(item)

    return flat_list

def flatten_list_of_lists(list_of_lists):
    "Flattens list of lists (not recursive)"
    return [item for sublist in list_of_lists for item in sublist]

def deduplicate_list(l):
    "Deduplicates list l"
    return list(set(l))

def chunk_list(input_list, chunksize):
    'Breaks `input_list` into chunks of size `chunksize`, ragged on last list'
    return [input_list[i:i+chunksize] for i in range(0, len(input_list), chunksize)]

# Cell
def maybe_parallel(func, iterable, cpus=None, **kwargs):

    func = partial(func, **kwargs)

    if is_container(iterable):

        if cpus is None:
            if 'ncpus' in os.environ.keys():
                cpus = int(os.environ['ncpus'])
            else:
                cpus = os.cpu_count()

        processes = min(cpus, len(iterable))

        if processes == 0:
            output = [func(i) for i in iterable]

        else:
            with Pool(processes=cpus) as p:
                output = p.map(func, iterable)

    else:
        output = func(iterable)

    return output